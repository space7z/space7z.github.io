<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>ysk-blog | ysk-blog</title><meta name="author" content="ysk"><meta name="copyright" content="ysk"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="基础软件测试的定义使用技术手段验证软件是否满足需求 常见的测试分类1、按阶段划分 单元测试：针对程序源代码进行测试  集成测试：针对程序接口进行测试  系统测试：针对程序功能、非功能进行测试  验收测试：使用不同用户（内测、公测）进行测试   2、按代码可见度划分 黑盒测试：不关注源代码，针对程序UI功能进行测试。（源代码不可见，UI功能可见）  灰盒测试：针对程序部分代码进行测试（接口）。（部分">
<meta property="og:type" content="article">
<meta property="og:title" content="ysk-blog">
<meta property="og:url" content="https://space7z.github.io/2024/01/08/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="ysk-blog">
<meta property="og:description" content="基础软件测试的定义使用技术手段验证软件是否满足需求 常见的测试分类1、按阶段划分 单元测试：针对程序源代码进行测试  集成测试：针对程序接口进行测试  系统测试：针对程序功能、非功能进行测试  验收测试：使用不同用户（内测、公测）进行测试   2、按代码可见度划分 黑盒测试：不关注源代码，针对程序UI功能进行测试。（源代码不可见，UI功能可见）  灰盒测试：针对程序部分代码进行测试（接口）。（部分">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://space7z.github.io/img/tx.jpg">
<meta property="article:published_time" content="2024-01-08T09:05:41.338Z">
<meta property="article:modified_time" content="2024-01-06T15:30:09.829Z">
<meta property="article:author" content="ysk">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://space7z.github.io/img/tx.jpg"><link rel="shortcut icon" href="/img/tx.jpg"><link rel="canonical" href="https://space7z.github.io/2024/01/08/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"2RU78TJR66","apiKey":"ad104b5657bf73e7ea82ee7cbbefcf4d","indexName":"hexo","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ysk-blog',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-06 23:30:09'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/tx.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/video/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('/img/background.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="ysk-blog"><span class="site-name">ysk-blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/video/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">无题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-08T09:05:41.338Z" title="发表于 2024-01-08 17:05:41">2024-01-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-06T15:30:09.829Z" title="更新于 2024-01-06 23:30:09">2024-01-06</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="软件测试的定义"><a href="#软件测试的定义" class="headerlink" title="软件测试的定义"></a>软件测试的定义</h2><p>使用技术手段验证软件是否满足需求</p>
<h2 id="常见的测试分类"><a href="#常见的测试分类" class="headerlink" title="常见的测试分类"></a>常见的测试分类</h2><h3 id="1、按阶段划分"><a href="#1、按阶段划分" class="headerlink" title="1、按阶段划分"></a>1、按阶段划分</h3><ul>
<li><p>单元测试：针对程序源代码进行测试</p>
</li>
<li><p>集成测试：针对程序接口进行测试</p>
</li>
<li><p>系统测试：针对程序功能、非功能进行测试</p>
</li>
<li><p>验收测试：使用不同用户（内测、公测）进行测试</p>
</li>
</ul>
<h3 id="2、按代码可见度划分"><a href="#2、按代码可见度划分" class="headerlink" title="2、按代码可见度划分"></a>2、按代码可见度划分</h3><ul>
<li><p>黑盒测试：不关注源代码，针对程序UI功能进行测试。（源代码不可见，UI功能可见）</p>
</li>
<li><p>灰盒测试：针对程序部分代码进行测试（接口）。（部分源代码可见，功能不可见）</p>
</li>
<li><p>白盒测试：针对程序源代码进行测试。（全部代码可见，UI功能不可见）</p>
</li>
</ul>
<h3 id="3、专项"><a href="#3、专项" class="headerlink" title="3、专项"></a>3、专项</h3><ul>
<li><p>性能测试</p>
</li>
<li><p>安全测试</p>
</li>
</ul>
<h2 id="质量模型的重点5项"><a href="#质量模型的重点5项" class="headerlink" title="质量模型的重点5项"></a>质量模型的重点5项</h2><ol>
<li>功能</li>
<li>性能</li>
<li>兼容</li>
<li>易用</li>
<li>安全</li>
</ol>
<h2 id="测试流程的6各步骤"><a href="#测试流程的6各步骤" class="headerlink" title="测试流程的6各步骤"></a>测试流程的6各步骤</h2><p>1、需求评审</p>
<ul>
<li><p>角色</p>
<ul>
<li><p>产品经理</p>
</li>
<li><p>开发</p>
</li>
<li><p>测试</p>
</li>
</ul>
</li>
<li><p>目的</p>
<ul>
<li>需求理解一致</li>
<li>知道被测项目有哪些功能模块</li>
</ul>
</li>
</ul>
<p>2、测试计划</p>
<ol>
<li>测什么</li>
<li>谁来测</li>
<li>怎么测</li>
</ol>
<p>3、用例设计</p>
<ul>
<li>针对穷举法进行设计</li>
</ul>
<p>4、用例执行</p>
<p>5、缺陷管理</p>
<p>6、测试报告</p>
<h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><h3 id="1、什么是用例？"><a href="#1、什么是用例？" class="headerlink" title="1、什么是用例？"></a>1、什么是用例？</h3><p>用例：用户使用的案例</p>
<h3 id="2、用例设计编写格式"><a href="#2、用例设计编写格式" class="headerlink" title="2、用例设计编写格式"></a>2、用例设计编写格式</h3><p>测试模板有8有要素</p>
<p>1、测试编号</p>
<p>项目简称_模块简称_编号</p>
<p>2、用例标题</p>
<p>预期结果（测试点）</p>
<p>3、项目&#x2F;模块</p>
<p>用例所属项目或模块</p>
<p>4、优先级</p>
<p>P0-P4（P0最高）</p>
<p>5、前置条件&#x2F;预置条件</p>
<p>操作步骤之前的操作</p>
<p>6、测试步骤</p>
<p>执行用例步骤</p>
<p>7、测试数据</p>
<p>执行步骤中的重点数据</p>
<p>8、预期结果</p>
<p>用例执行结果+不同角色隐性结果</p>
<table>
<thead>
<tr>
<th>用例编号</th>
<th>用例标题</th>
<th>项目&#x2F;模块</th>
<th>优先级</th>
<th>前置条件</th>
<th>测试步骤</th>
<th>测试数据</th>
<th>预期结果</th>
</tr>
</thead>
<tbody><tr>
<td>hm_login_001</td>
<td>登陆成功（正确手机号）</td>
<td>登录</td>
<td>P0</td>
<td>1、打开登录页面2、手机已注册</td>
<td>1、输入手机号2、点击发送验证码按钮3、拖曳滑块成功4、输入验证码5、勾选协议6、点击登录</td>
<td>1、手机：已注册手机号2、其他输入正确数据</td>
<td>1、数据文本框状态为绿色2、登录成功、跳转到主页</td>
</tr>
<tr>
<td>hm_login_001</td>
<td>登录失败（手机号为空）</td>
<td>登录</td>
<td>p1</td>
<td>1、打开登录页面</td>
<td>1、输入手机号2、点击发送验证码3、输入验证码4、勾选协议5、点击登录</td>
<td>1、手机：为空2、验证码：88883、其他输入正确数据</td>
<td>1、手机文本框状态为红色2、点击发送验证码按钮，不弹出滑块3、登录失败，提示手机号不能为空</td>
</tr>
</tbody></table>
<h3 id="测试用例的设计方法"><a href="#测试用例的设计方法" class="headerlink" title="测试用例的设计方法"></a>测试用例的设计方法</h3><h4 id="等价类划分法"><a href="#等价类划分法" class="headerlink" title="等价类划分法"></a>等价类划分法</h4><h5 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h5><p>在所有测试数据中，具有某种共同特征的数据集合进行划分。</p>
<h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><ul>
<li>有效等价类：满足需求的数据集合</li>
<li>无效等价类：不满足需求的数据集合</li>
</ul>
<h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ol>
<li>明确需求</li>
<li>确定有效和无效等价类</li>
<li>提取数据编写测试用例</li>
</ol>
<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>比如对qq登录进行测试</p>
<p>1、明确需求：</p>
<ul>
<li>长度：要求为6~10位自然数</li>
<li>类型：自然数</li>
</ul>
<p>2、划分有效等价和无效等价</p>
<ul>
<li><p>有效：8位</p>
</li>
<li><p>无效：</p>
<ul>
<li>3位</li>
<li>12位</li>
<li>8为非自然数</li>
</ul>
</li>
</ul>
<p>3、提取数据编写用例</p>
<ul>
<li>有效：12345678</li>
<li>无效：123456789012</li>
</ul>
<h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><p>针对：需要有大量数据测试输入，但是没法穷举测试的地方。</p>
<ul>
<li>输入框</li>
<li>下拉列表</li>
<li>单选复选框</li>
</ul>
<p>典型代表：页面的输入框类测试。</p>
<h4 id="边界值法"><a href="#边界值法" class="headerlink" title="边界值法"></a>边界值法</h4><ul>
<li>介绍</li>
</ul>
<p>边界值分析法就是对输入或输出边界值进行测试的.也是一种黑盒测试.边界值分析法通常作为等价类划分法的补充,其测试用例来自等价类的边界;长期的经验得知,大量的错误是发现在输入或输出范围的边界上，而不是发生再输入输出范围的内部，因此针对各种边界情况设计测试用例，可以查出更多错误.</p>
<ul>
<li><p>与等价类划分法的区别:</p>
<ul>
<li><p>等价类划分法可以挑选等价范围内任意一个数据作为代表边界值分析法要求每个边界值都要作为测试条件。</p>
</li>
<li><p>边界值分析法不仅考虑输入条件,同样考虑输出产生的测试情况。</p>
</li>
</ul>
</li>
</ul>
<h2 id="测试模型"><a href="#测试模型" class="headerlink" title="测试模型"></a>测试模型</h2><h3 id="V模型"><a href="#V模型" class="headerlink" title="V模型"></a>V模型</h3><p>是软件开发瀑布模型的变种，主要反映了测试活动与分析与设计的关系；</p>
<p>局限性：把测试作为编码之后的最后一个活动，需求分析等前期产生的错误直到后期的验收测试才可以发现。</p>
<h3 id="W模型"><a href="#W模型" class="headerlink" title="W模型"></a>W模型</h3><p>在V模型的基础上，增加开发阶段的同步测试，形成W模型；测试与开发同步进行，有利用及早的发现问题；</p>
<p>局限性：仍把开发活动看成是从需求开始到编码结束的串行活动，只有上一阶段完成后，才可以开始下一阶段的活动，不能支持迭代，自发性及其变更调整。</p>
<h2 id="软件缺陷"><a href="#软件缺陷" class="headerlink" title="软件缺陷"></a>软件缺陷</h2><ul>
<li>定义<ul>
<li>从内部看，软件缺陷试产品开发或者维护过程中存在的错误、毛病等各种问题</li>
<li>从外部看，软件缺陷是系统所需要实现的某种功能的失效或者违背</li>
<li>总的来说，缺陷就是问题，最终表现为所需要的功能没有完全实现，没有满足用户的需求。</li>
</ul>
</li>
</ul>
<h1 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h1><h2 id="什么是自动化测试？"><a href="#什么是自动化测试？" class="headerlink" title="什么是自动化测试？"></a>什么是自动化测试？</h2><ul>
<li>程序测试程序</li>
<li>代码代替思维</li>
<li>脚本代替人工</li>
</ul>
<p>自动化测试覆盖</p>
<ul>
<li>黑盒自动化测试</li>
<li>白盒自动化测试</li>
<li>性能测试</li>
<li>压力测试</li>
<li>GUI测试</li>
<li>安全性测试</li>
</ul>
<p>狭义定义：</p>
<p>自动化测试通过工具记录或编写脚本的方式模拟手工测试的过程，通过回放或运行脚本来执行测试用例，从而代替人工对系统的功能进行验证。</p>
<p>广义定义：</p>
<p>自动化测试包括一切通过工具（程序)的方式来代替或辅助手工测试的行为，包括接口测试(REST Assured、Postman) 、性能测试工具(LoadRunner、JMeter)和自己所写的一段程序。</p>
<p>作用：</p>
<p>节省人力、物力、时间、硬件资源等，提升测试效率，特别是对于烦琐重复的测试用例，可以使测试人员更专注于新的测试模块的建立和开发，从而提高测试覆盖率。</p>
<h2 id="自动化测试常用工具"><a href="#自动化测试常用工具" class="headerlink" title="自动化测试常用工具"></a>自动化测试常用工具</h2><h3 id="接口-UI自动化测试框架"><a href="#接口-UI自动化测试框架" class="headerlink" title="接口&#x2F;UI自动化测试框架"></a>接口&#x2F;UI自动化测试框架</h3><ul>
<li>Robot Framework</li>
<li>Selenium</li>
<li>Jmeter</li>
<li>SoapUI</li>
</ul>
<h3 id="移动自动化测试框架"><a href="#移动自动化测试框架" class="headerlink" title="移动自动化测试框架"></a>移动自动化测试框架</h3><ul>
<li>Robotium</li>
<li>Applum</li>
<li>MonkeyRunner</li>
<li>Monkey</li>
</ul>
<h2 id="selenium"><a href="#selenium" class="headerlink" title="selenium"></a>selenium</h2><p>官方文档</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.selenium.dev/documentation/webdriver/</span><br></pre></td></tr></table></figure>



<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Selenium是一个用于Web应用程序测试的工具;中文的意思（硒)</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>开源软件：源代码开放可以根据需要来增加工具的某些功能跨平台: linux . windows . mac</li>
<li>核心功能：就是可以在多个浏览器上进行自动化测试多语言:Java、Python、C#、JavaScript、Ruby等</li>
<li>成熟稳定：目前已经被google ,百度，腾讯等公司广泛使用</li>
<li>功能强大：能够实现类似商业工具的大部分功能，因为开源性，可实现定制化功能</li>
</ol>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>使用版本：4.11.0</p>
<p>安装</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install -i https://mirrors.aliyun.com/pypi/simple/ selenium</span><br></pre></td></tr></table></figure>



<p>基本配置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line"><span class="comment"># 打开网址</span></span><br><span class="line">driver.get(<span class="string">&#x27;https://www.baidu.com/&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p>常用方法</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取当前页面url</span></span><br><span class="line">driver.current_url</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前html源码</span></span><br><span class="line">driver.page_source</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前页面标题</span></span><br><span class="line">driver.title</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取浏览器名称(chrome)</span></span><br><span class="line">driver.name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对页面进行截图，返回二进制数据</span></span><br><span class="line">driver.get_screenshot_as_png()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置浏览器尺寸</span></span><br><span class="line">driver.get_window_size()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取浏览器尺寸，位置</span></span><br><span class="line">driver.get_window_rect()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取浏览器位置(左上角)</span></span><br><span class="line">driver.get_window_position()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置浏览器尺寸</span></span><br><span class="line">driver.set_window_size(width=<span class="number">1000</span>, height=<span class="number">600</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置浏览器位置(左上角)</span></span><br><span class="line">driver.set_window_position(x=<span class="number">500</span>, y=<span class="number">600</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置浏览器的尺寸，位置</span></span><br><span class="line">driver.set_window_rect(x=<span class="number">200</span>, y=<span class="number">400</span>, width=<span class="number">1000</span>, height=<span class="number">600</span>)</span><br></pre></td></tr></table></figure>



<h4 id="1、元素操作方法"><a href="#1、元素操作方法" class="headerlink" title="1、元素操作方法"></a>1、元素操作方法</h4><h5 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ele = driver.find_element(By.XPATH,&#x27;XPATH&#x27;)</span><br><span class="line">ele = driver.find_element(By.CLASS_NAME,&#x27;CLASS_NAME&#x27;)</span><br><span class="line">ele = driver.find_element(By.CSS_SELECTOR,&#x27;CSS_SELECTOR&#x27;)</span><br><span class="line">ele = driver.find_element(By.ID,&#x27;ID&#x27;)</span><br><span class="line">ele = driver.find_element(By.LINK_TEXT,&#x27;LINK_TEXT&#x27;)</span><br><span class="line">ele = driver.find_element(By.PARTIAL_LINK_TEXT,&#x27;PARTIAL_LINK_TEXT&#x27;)</span><br><span class="line">ele = driver.find_element(By.TAG_NAME,&#x27;TAG_NAME&#x27;)</span><br></pre></td></tr></table></figure>



<h5 id="操作元素"><a href="#操作元素" class="headerlink" title="操作元素"></a>操作元素</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入方法:</span><br><span class="line">ele.send_keys() </span><br><span class="line"></span><br><span class="line">点击方法：</span><br><span class="line">ele.click()</span><br><span class="line"></span><br><span class="line">清空方法</span><br><span class="line">ele.clear()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：输入方法之前一定要清空操作</p>
</blockquote>
<p>基本示例</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line"><span class="comment"># 打开网址</span></span><br><span class="line">driver.get(<span class="string">&#x27;https://www.baidu.com/&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需求</span></span><br><span class="line">ele = driver.find_element(By.ID,<span class="string">&quot;kw&quot;</span>)</span><br><span class="line">ele.send_keys(<span class="string">&#x27;周杰伦&#x27;</span>)</span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空</span></span><br><span class="line">ele.clear()</span><br><span class="line">ele.send_keys(<span class="string">&#x27;王嘉尔&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间轴看效果</span></span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭页面</span></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>





<h5 id="等待元素出现"><a href="#等待元素出现" class="headerlink" title="等待元素出现"></a>等待元素出现</h5><p>有时候某个元素不是直接出现的，如果不做判断则会导致程序崩溃，因此一般可以做异常处理，这里还有等待元素出现的方法。</p>
<p>1、为什么要设置元素等待</p>
<ul>
<li>由于电脑配置或网络原因，在查找元素时，元素代码未在第一时间内被加载出来，而抛出未找到元素异常。</li>
</ul>
<p>2、什么是元素等待</p>
<ul>
<li>元素在第一次未找到时，元素等待设置的时长被激活，如果在设置的有效时长内找到元素，继续执行代码，如果超出设置的时长未找打元素，抛出未找到元素异常。</li>
</ul>
<p>首先，需要导入等待的包</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br></pre></td></tr></table></figure>



<p>然后，使用以下方法等待元素出现，<code>driver</code>就是浏览器驱动，<code>timeout</code>就是等待的时长，<code>until</code>后是判断元素是否出现的</p>
<p>方式一 显式等待：针对全局元素生效</p>
<p>等待元素出现之后返回元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例1</span></span><br><span class="line">el = WebDriverWait(driver, timeout=<span class="number">3</span>).until(<span class="keyword">lambda</span> d: d.find_element_by_tag_name(<span class="string">&quot;p&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例2</span></span><br><span class="line">element = WebDriverWait(driver, <span class="number">5</span>, <span class="number">0.5</span>).until(</span><br><span class="line">            EC.presence_of_element_located((By.ID, <span class="string">&#x27;kw&#x27;</span>)),</span><br><span class="line">                                           message=<span class="string">&#x27;超时啦!&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p>方式二 隐式等待：针对全局元素生效</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.implicitly_wait(<span class="number">30</span>) <span class="comment"># 一般情况下设置30秒</span></span><br></pre></td></tr></table></figure>

<p>例</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(<span class="string">&#x27;https://blog.csdn.net/qq_43965708&#x27;</span>)</span><br><span class="line"></span><br><span class="line">start = time()</span><br><span class="line">driver.implicitly_wait(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    driver.find_element_by_id(<span class="string">&#x27;kw&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;耗时：<span class="subst">&#123;time()-start&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>代码运行到 <code>driver.find_element_by_id(&#39;kw&#39;)</code> 这句之后触发隐式等待，在轮询检查 5s 后仍然没有定位到元素，抛出异常。</p>
</blockquote>
<h4 id="2、浏览器操作方法"><a href="#2、浏览器操作方法" class="headerlink" title="2、浏览器操作方法"></a>2、浏览器操作方法</h4><p>常用的浏览器操作系统API</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、driver.maximize_window()  # 最大化浏览器</span><br><span class="line">2、driver.set_window_size(w,h)  # 设置浏览器大小 单位像素 【了解】</span><br><span class="line">3、driver.set_window_position(x,y)  # 设置浏览器位置  【了解】</span><br><span class="line">4、driver.back() # 后退操作</span><br><span class="line">5、driver.forward() # 前进操作</span><br><span class="line">6、driver.refrensh() # 刷新操作</span><br><span class="line">7、driver.close() # 关闭当前主窗口（主窗口：默认启动那个界面，就是主窗口）</span><br><span class="line">8、driver.quit() # 关闭driver对象启动的全部页面</span><br><span class="line">9、driver.title # 获取当前页面title信息</span><br><span class="line">10、driver.current_url # 获取当前页面url信息</span><br></pre></td></tr></table></figure>



<h4 id="3、鼠标控制"><a href="#3、鼠标控制" class="headerlink" title="3、鼠标控制"></a>3、鼠标控制</h4><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>click()</td>
<td>单击左键</td>
</tr>
<tr>
<td>context_click()</td>
<td>单击右键</td>
</tr>
<tr>
<td>double_click()</td>
<td>双击</td>
</tr>
<tr>
<td>drag_and_drop()</td>
<td>拖动</td>
</tr>
<tr>
<td>move_to_element()</td>
<td>鼠标悬停</td>
</tr>
<tr>
<td>perform()</td>
<td>执行所有ActionChains中存储的动作</td>
</tr>
</tbody></table>
<p>单击左键</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定位搜索按钮</span></span><br><span class="line">button = driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;toolbar-search-button&quot;]/span&#x27;</span>)</span><br><span class="line"><span class="comment"># 执行单击操作</span></span><br><span class="line">button.click()</span><br></pre></td></tr></table></figure>



<p>单击右键</p>
<p>鼠标右击的操作与左击有很大不同，需要使用 <code>ActionChains</code> 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开网址</span></span><br><span class="line">driver.maximize_window()</span><br><span class="line">driver.get(<span class="string">&#x27;https://www.baidu.com/&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ele = driver.find_element(By.ID,<span class="string">&quot;su&quot;</span>)</span><br><span class="line"><span class="comment"># 右击</span></span><br><span class="line">ActionChains(driver).context_click(ele).perform()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间轴看效果</span></span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭页面</span></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>



<p>双击</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行双击动作</span></span><br><span class="line">ActionChains(driver).double_click(ele).perform()</span><br></pre></td></tr></table></figure>



<p>拖动</p>
<p>模拟鼠标拖动操作，该操作有两个必要参数</p>
<ul>
<li>source：鼠标拖动的元素</li>
<li>target：鼠标拖至并释放的目标元素</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开网址</span></span><br><span class="line">driver.get(<span class="string">&#x27;https://www.baidu.com/&#x27;</span>)</span><br><span class="line">ele_input = driver.find_element(By.XPATH,<span class="string">&#x27;//*[@id=&quot;kw&quot;]&#x27;</span>)</span><br><span class="line">ele_input.send_keys(<span class="string">&quot;图片&quot;</span>)</span><br><span class="line">ele_btn = driver.find_element(By.ID,<span class="string">&#x27;su&#x27;</span>)</span><br><span class="line">ele_btn.click()</span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line">ele_img = driver.find_element(By.XPATH,<span class="string">&#x27;//*[@id=&quot;1&quot;]/div/div[1]/div[2]/div[1]/a[1]/img&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行拖动动作</span></span><br><span class="line">ActionChains(driver).drag_and_drop(ele_img, ele_input).perform()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间轴看效果</span></span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭页面</span></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>



<p>鼠标悬停</p>
<p>模拟悬停的作用一般是为了显示隐藏的下拉框，比如 CSDN 主页的收藏栏，我们看一下效果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line"><span class="comment"># 打开网址</span></span><br><span class="line">driver.get(<span class="string">&#x27;https://www.baidu.com/&#x27;</span>)</span><br><span class="line">ele_more = driver.find_element(By.XPATH,<span class="string">&#x27;//*[@id=&quot;s-top-left&quot;]/div/a&#x27;</span>)</span><br><span class="line"><span class="comment"># 悬停</span></span><br><span class="line">ActionChains(driver).move_to_element(ele_more).perform()</span><br><span class="line"><span class="comment"># 时间轴看效果</span></span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 关闭页面</span></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>



<h4 id="4、键盘操作"><a href="#4、键盘操作" class="headerlink" title="4、键盘操作"></a>4、键盘操作</h4><p>键盘对应的方法在Keys类</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br></pre></td></tr></table></figure>



<p>应用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单键</span></span><br><span class="line">element.send_keys(Keys.XXX)</span><br><span class="line"><span class="comment"># 组合键</span></span><br><span class="line">element.send_keys(Keys.XXX, <span class="string">&#x27;a&#x27;</span>) <span class="comment"># 注意这里的组合键都是小写</span></span><br></pre></td></tr></table></figure>



<p>示例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开网址</span></span><br><span class="line">driver.get(<span class="string">&#x27;https://www.baidu.com/&#x27;</span>)</span><br><span class="line">driver.implicitly_wait(<span class="number">30</span>) <span class="comment"># 一般情况下设置30秒</span></span><br><span class="line"></span><br><span class="line">ele_inp = driver.find_element(By.ID,<span class="string">&#x27;kw&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ele_inp.send_keys(<span class="string">&quot;周杰伦&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全选</span></span><br><span class="line">ele_inp.send_keys(Keys.CONTROL,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment"># 复制</span></span><br><span class="line">ele_inp.send_keys(Keys.CONTROL,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 清空</span></span><br><span class="line">ele_inp.clear()</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 粘贴</span></span><br><span class="line">ele_inp.send_keys(Keys.CONTROL,<span class="string">&#x27;v&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间轴看效果</span></span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭页面</span></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>



<h4 id="5、下拉框"><a href="#5、下拉框" class="headerlink" title="5、下拉框"></a>5、下拉框</h4><p>为什么单独使用下拉框？</p>
<ul>
<li>如果option选项没有value值的化，css定位或其他定位就不太方便。</li>
</ul>
<p><strong>应用</strong></p>
<p>1、导包</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.support.select <span class="keyword">import</span> Select</span><br></pre></td></tr></table></figure>

<p>2、实例化下拉框</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = Select(element)</span><br></pre></td></tr></table></figure>

<p>3、调用方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.select_by_index()</span><br></pre></td></tr></table></figure>



<p><strong>Select类提供的方法</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过索引定位选择</span></span><br><span class="line">select_by_index()</span><br><span class="line"><span class="comment"># 通过value值选择</span></span><br><span class="line">select _by_value()</span><br><span class="line"><span class="comment"># 通过的显示文本选择</span></span><br><span class="line">select_by_visible_text()</span><br></pre></td></tr></table></figure>



<p>示例</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.select <span class="keyword">import</span> Select</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开网址</span></span><br><span class="line">driver.get(<span class="string">&#x27;http://127.0.0.1:5500/index.html&#x27;</span>)</span><br><span class="line">driver.implicitly_wait(<span class="number">30</span>) <span class="comment"># 一般情况下设置30秒</span></span><br><span class="line"></span><br><span class="line">ele_inp = driver.find_element(By.XPATH,<span class="string">&#x27;//*[@id=&quot;select_ele&quot;]&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化select元素</span></span><br><span class="line">s = Select(ele_inp)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 通过索引选择</span></span><br><span class="line">s.select_by_index(<span class="number">1</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 通过value值选择</span></span><br><span class="line">s.select_by_value(<span class="string">&quot;option4&quot;</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 通过文本值选择</span></span><br><span class="line">s.select_by_visible_text(<span class="string">&quot;选项3&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间轴看效果</span></span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭页面</span></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>



<h4 id="6、弹出框"><a href="#6、弹出框" class="headerlink" title="6、弹出框"></a>6、弹出框</h4><p>为什么要处理弹出框？</p>
<ul>
<li>一旦出现弹出框，如果不进行处理，则后续操作不可实现</li>
</ul>
<p>弹窗分类</p>
<ul>
<li>系统弹窗：JS实现</li>
<li>自定义弹窗：前端代码封装</li>
</ul>
<p>对话框的分类：</p>
<ul>
<li>alert：警告框</li>
<li>confirm：确认框</li>
<li>prompt：提示框</li>
</ul>
<p>处理步骤</p>
<p>1、切换到对话框</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.switch_to.alert</span><br></pre></td></tr></table></figure>

<p>2、处理对话框</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert.text <span class="comment"># 获取文本</span></span><br><span class="line">alert.accept() <span class="comment"># 接受</span></span><br><span class="line">alert.dismiss() <span class="comment"># 拒接</span></span><br></pre></td></tr></table></figure>



<p>示例</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.select <span class="keyword">import</span> Select</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开网址</span></span><br><span class="line">driver.get(<span class="string">&#x27;http://127.0.0.1:5500/index.html&#x27;</span>)</span><br><span class="line">driver.implicitly_wait(<span class="number">30</span>) <span class="comment"># 一般情况下设置30秒</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换对话框</span></span><br><span class="line">alert = driver.switch_to.alert</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;文本内容是：&#x27;</span>,alert.text)</span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接受</span></span><br><span class="line">alert.accept()</span><br><span class="line"><span class="comment"># 拒绝</span></span><br><span class="line"><span class="comment"># alert.dismiss()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间轴看效果</span></span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭页面</span></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>



<h4 id="7、滚动轮"><a href="#7、滚动轮" class="headerlink" title="7、滚动轮"></a>7、滚动轮</h4><p>为什么要有滚动条？</p>
<ul>
<li>在一些特殊场景中，一些按钮是在页面最下角，需要使用滚动条拉到最底层。</li>
</ul>
<p>操作步骤</p>
<p>Selenium框架中没有专门处理滚动条的方法，需要通过调用 <code>Js</code> 代码实现操作；</p>
<p>1、设置操作滚动条操作语句</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">js_down=<span class="string">&quot;window.scollTo(0,1000)&quot;</span></span><br><span class="line"><span class="comment"># 0:为左边距-----》水平滚动条</span></span><br><span class="line"><span class="comment"># 1000: 为垂直滚动条</span></span><br></pre></td></tr></table></figure>



<p>2、调用执行js方法，将设置js语句传入方法中</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.execute_script(js_down)</span><br></pre></td></tr></table></figure>



<p>示例</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.select <span class="keyword">import</span> Select</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开网址</span></span><br><span class="line">driver.get(<span class="string">&#x27;https://blog.csdn.net/qq_43965708/article/details/120658713?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170408129016800225533318%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=170408129016800225533318&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-120658713-null-null.142^v99^pc_search_result_base5&amp;utm_term=selenium&amp;spm=1018.2226.3001.4187&#x27;</span>)</span><br><span class="line">driver.maximize_window()</span><br><span class="line">driver.implicitly_wait(<span class="number">30</span>) <span class="comment"># 一般情况下设置30秒</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 滑动到具体位置</span></span><br><span class="line"><span class="comment"># js_down = &quot;window.scrollTo(0,1000)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 向下滑动至目标元素可见</span></span><br><span class="line">js_to_target = <span class="string">&quot;arguments[0].scrollIntoView();&quot;</span></span><br><span class="line"><span class="comment"># 向上滑动至目标元素</span></span><br><span class="line">js_to_target_revel = <span class="string">&quot;arguments[0].scrollIntoView(false);&quot;</span></span><br><span class="line"><span class="comment"># 定位要滑动到的元素</span></span><br><span class="line">ele = driver.find_element(By.XPATH,<span class="string">&#x27;//*[@id=&quot;content_views&quot;]/h3[1]&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 滑动至底部</span></span><br><span class="line">js_to_bottom = <span class="string">&quot;window.scrollTo(0,document.body.scrollHeight)&quot;</span></span><br><span class="line"></span><br><span class="line">driver.execute_script(js_to_bottom)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">driver.execute_script(js_to_target_revel,ele)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间轴看效果</span></span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭页面</span></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>



<h4 id="8、切换frame表单"><a href="#8、切换frame表单" class="headerlink" title="8、切换frame表单"></a>8、切换frame表单</h4><p>应用场景</p>
<ul>
<li>处于frame 中的元素，虽然可以获取元素信息，但是代码执行时无法定位元素，因此需要<code>先切换到frame</code>，再进行元素定位操作。</li>
</ul>
<p>应用</p>
<p>切换方法</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 传入的是代表frame唯一的特征值</span></span><br><span class="line">driver.switch_to.frame(<span class="string">&quot;id/name/element&quot;</span>) </span><br></pre></td></tr></table></figure>



<h4 id="9、多窗口的切换"><a href="#9、多窗口的切换" class="headerlink" title="9、多窗口的切换"></a>9、多窗口的切换</h4><p>为什么要切换多窗口？</p>
<ul>
<li><p>在 <code>selenium</code> 操作页面的时候，可能会因为点击某个链接而跳转到一个新的页面（打开了一个新标签页），这时候 <code>selenium</code> 实际还是处于上一个页面的，需要我们进行切换才能够定位最新页面上的元素。</p>
</li>
<li><p>页面是存在多窗口的，但是selenium默认焦点只会在<code>主窗口</code>上的所有元素，不切换窗口，就不能操作除主窗口以外的窗口内元素。</p>
</li>
</ul>
<p>如何切换</p>
<ul>
<li><p>每个窗口都有唯一的一个句柄值，那么我们就可以通过句柄值来完成窗口的切换操作</p>
</li>
<li><p>窗口切换需要使用 <code>switch_to.windows()</code> 方法。</p>
</li>
</ul>
<p>方法</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">driver.current_window_handle <span class="comment">#(获取当前的句柄值)</span></span><br><span class="line">driver.window_handles <span class="comment">#（ 获取当前由driver启动所有窗口句柄）</span></span><br><span class="line">driver.switch_to.window(handle) <span class="comment">#—&gt; 切换窗口</span></span><br></pre></td></tr></table></figure>



<h4 id="10、截图操作"><a href="#10、截图操作" class="headerlink" title="10、截图操作"></a>10、截图操作</h4><p>使用方法</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">driver.get_screenshot_as_file(imgepath)</span><br><span class="line"><span class="comment"># imagepath：为图片要保存的目录地址及文件名称</span></span><br></pre></td></tr></table></figure>



<p>示例</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.select <span class="keyword">import</span> Select</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开网址</span></span><br><span class="line">driver.get(<span class="string">&#x27;https://www.baidu.com/&#x27;</span>)</span><br><span class="line">driver.maximize_window()</span><br><span class="line">driver.implicitly_wait(<span class="number">30</span>) <span class="comment"># 一般情况下设置30秒</span></span><br><span class="line"></span><br><span class="line">ele = driver.find_element(By.XPATH,<span class="string">&#x27;//*[@id=&quot;s-top-left&quot;]/div/a&#x27;</span>)</span><br><span class="line">ActionChains(driver).move_to_element(ele).perform()</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">driver.get_screenshot_as_file(<span class="string">&quot;./screenshot/test.png&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间轴看效果</span></span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭页面</span></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>



<h4 id="11、验证码"><a href="#11、验证码" class="headerlink" title="11、验证码"></a>11、验证码</h4><p>1、什么是验证码？</p>
<ul>
<li>一种随机生成的信息（文字，数字，图片）</li>
</ul>
<p>2、验证码的作用？</p>
<ul>
<li>防止恶意请求</li>
</ul>
<p>3、验证码的处理</p>
<ul>
<li>这里是用cookie解决</li>
</ul>
<p>4、使用cookie 登录</p>
<ul>
<li>客户端登录账号后，将登录状态的想关 cookie 信息发给服务器保存，再发送去请求，携带cookie信息如果跟服务器保留的一致，则服务器认为客户端是登录状态。</li>
</ul>
<p>实现的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、整理cookie信息为字典数据，对应的是name和value，保存的一个变量中</span><br><span class="line">2、调用方法添加cookie</span><br><span class="line">	driver.add_cookie(cookie变量)</span><br><span class="line"># 3、刷新页面 --&gt;发送cookie给服务器验证</span><br><span class="line">	driver.refresh()</span><br></pre></td></tr></table></figure>



<p><strong>示例</strong></p>
<p>实现自动登录功能</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="动作API（selenium4新增）"><a href="#动作API（selenium4新增）" class="headerlink" title="动作API（selenium4新增）"></a>动作API（selenium4新增）</h4><p>动作API分为四个部分，分别是<code>键盘</code>、<code>鼠标</code>、<code>笔</code>、<code>滚轮</code>。这里先说明以下公共部分的。</p>
<h5 id="暂停（pause）"><a href="#暂停（pause）" class="headerlink" title="暂停（pause）"></a>暂停（pause）</h5><p>光标移动，滚轮滚动期间，会有一些时间空隙，这里可以使用暂停来实现，这里是支持链式调用的，这里贴出官方给出的例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">clickable = driver.find_element(By.ID, <span class="string">&quot;clickable&quot;</span>)</span><br><span class="line">ActionChains(driver)\</span><br><span class="line">        .move_to_element(clickable)\</span><br><span class="line">        .pause(<span class="number">1</span>)\</span><br><span class="line">        .click_and_hold()\</span><br><span class="line">        .pause(<span class="number">1</span>)\</span><br><span class="line">        .send_keys(<span class="string">&quot;abc&quot;</span>)\</span><br><span class="line">        .perform()</span><br></pre></td></tr></table></figure>



<h5 id="释放所有动作"><a href="#释放所有动作" class="headerlink" title="释放所有动作"></a>释放所有动作</h5><p>当前有动作执行时，可以使用以下方法停止这些动作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ActionBuilder(driver).clear_actions()</span><br></pre></td></tr></table></figure>



<h5 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h5><p>键盘代码表</p>
<p>地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/SeleniumHQ/selenium/blob/selenium-4.2.0/py/selenium/webdriver/common/keys.py#L23</span><br></pre></td></tr></table></figure>



<p>按下某键，以输入<code>shift+abc</code>为例</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ActionChains(driver)\</span><br><span class="line">    .key_down(Keys.SHIFT)\</span><br><span class="line">    .send_keys(<span class="string">&quot;abc&quot;</span>)\</span><br><span class="line">    .perform()</span><br></pre></td></tr></table></figure>



<p>弹起某键，以输入<code>shift+a</code>和<code>shift+b</code>为例，</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ActionChains(driver)\</span><br><span class="line">    .key_down(Keys.SHIFT)\</span><br><span class="line">    .send_keys(<span class="string">&quot;a&quot;</span>)\</span><br><span class="line">    .key_up(Keys.SHIFT)\</span><br><span class="line">    .send_keys(<span class="string">&quot;b&quot;</span>)\</span><br><span class="line">    .perform()</span><br></pre></td></tr></table></figure>



<p>浏览器输入某串字符（不指定元素)</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ActionChains(driver)\</span><br><span class="line">    .send_keys(<span class="string">&quot;abc&quot;</span>)\</span><br><span class="line">    .perform()</span><br></pre></td></tr></table></figure>



<p>指定元素输入字符串</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">text_input = driver.find_element(By.ID, <span class="string">&quot;textInput&quot;</span>)</span><br><span class="line">ActionChains(driver)\</span><br><span class="line">    .send_keys_to_element(text_input, <span class="string">&quot;abc&quot;</span>)\</span><br><span class="line">    .perform()</span><br></pre></td></tr></table></figure>



<p>复制和粘贴</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cmd_ctrl = Keys.COMMAND <span class="keyword">if</span> sys.platform == <span class="string">&#x27;darwin&#x27;</span> <span class="keyword">else</span> Keys.CONTROL</span><br><span class="line">ActionChains(driver)\</span><br><span class="line">        .send_keys(<span class="string">&quot;Selenium!&quot;</span>)\</span><br><span class="line">        .send_keys(Keys.ARROW_LEFT)\</span><br><span class="line">        .key_down(Keys.SHIFT)\</span><br><span class="line">        .send_keys(Keys.ARROW_UP)\</span><br><span class="line">        .key_up(Keys.SHIFT)\</span><br><span class="line">        .key_down(cmd_ctrl)\</span><br><span class="line">        .send_keys(<span class="string">&quot;xvv&quot;</span>)\</span><br><span class="line">        .key_up(cmd_ctrl)\</span><br><span class="line">        .perform()</span><br></pre></td></tr></table></figure>



<h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><h4 id="selenium隐藏指纹特征"><a href="#selenium隐藏指纹特征" class="headerlink" title="selenium隐藏指纹特征"></a>selenium隐藏指纹特征</h4><p><code>selenium</code> 对于部分网站来说十分强大，但它也不是万能的，实际上，<code>selenium</code> 启动的浏览器，有几十个特征可以被网站检测到，轻松的识别出你是爬虫。</p>
<p>首先你手动打开浏览器输入<a target="_blank" rel="noopener" href="https://bot.sannysoft.com/%EF%BC%8C%E5%9C%A8%E7%BD%91%E7%BB%9C%E6%97%A0%E5%BC%82%E5%B8%B8%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E6%98%BE%E7%A4%BA%E5%BA%94%E8%AF%A5%E5%A6%82%E4%B8%8B%EF%BC%9A">https://bot.sannysoft.com/，在网络无异常的情况下，显示应该如下：</a></p>
<p>下面通过 <code>selenium</code> 来打开浏览器。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(<span class="string">&#x27;https://bot.sannysoft.com/&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p>使用stealth.min.js</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置无头浏览器</span></span><br><span class="line">option = webdriver.ChromeOptions()</span><br><span class="line">option.add_argument(<span class="string">&#x27;--headless&#x27;</span>)</span><br><span class="line"><span class="comment"># 无头浏览器需要添加user-agent来隐藏特征</span></span><br><span class="line">option.add_argument(<span class="string">&#x27;user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36&#x27;</span>)</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome(options=option)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;stealth.min.js&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    js = f.read()</span><br><span class="line"></span><br><span class="line">driver.execute_cdp_cmd(<span class="string">&quot;Page.addScriptToEvaluateOnNewDocument&quot;</span>, &#123;</span><br><span class="line">  <span class="string">&quot;source&quot;</span>: js</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">driver.get(<span class="string">&#x27;https://bot.sannysoft.com/&#x27;</span>)</span><br><span class="line"></span><br><span class="line">driver.save_screenshot(<span class="string">&quot;page2.png&quot;</span>)</span><br><span class="line">sleep(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>



<p>stealth.min.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * Note: Auto-generated, do not update manually.</span></span><br><span class="line"><span class="comment"> * Generated by: https://github.com/berstend/puppeteer-extra/tree/master/packages/extract-stealth-evasions</span></span><br><span class="line"><span class="comment"> * Generated on: Mon, 25 Dec 2023 06:18:16 GMT</span></span><br><span class="line"><span class="comment"> * License: MIT</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">(<span class="function">(<span class="params">&#123;_utilsFns:_utilsFns,_mainFunction:_mainFunction,_args:_args&#125;</span>)=&gt;</span>&#123;<span class="keyword">const</span> utils=<span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(_utilsFns).<span class="title function_">map</span>((<span class="function">(<span class="params">[key,value]</span>)=&gt;</span>[key,<span class="built_in">eval</span>(value)])));utils.<span class="title function_">init</span>(),<span class="built_in">eval</span>(_mainFunction)(utils,..._args)&#125;)(&#123;<span class="attr">_utilsFns</span>:&#123;<span class="attr">init</span>:<span class="string">&quot;() =&gt; &#123;\n  utils.preloadCache()\n&#125;&quot;</span>,<span class="attr">stripProxyFromErrors</span>:<span class="string">&quot;(handler = &#123;&#125;) =&gt; &#123;\n  const newHandler = &#123;\n    setPrototypeOf: function (target, proto) &#123;\n      if (proto === null)\n        throw new TypeError(&#x27;Cannot convert object to primitive value&#x27;)\n      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) &#123;\n        throw new TypeError(&#x27;Cyclic __proto__ value&#x27;)\n      &#125;\n      return Reflect.setPrototypeOf(target, proto)\n    &#125;\n  &#125;\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\n  const traps = Object.getOwnPropertyNames(handler)\n  traps.forEach(trap =&gt; &#123;\n    newHandler[trap] = function () &#123;\n      try &#123;\n        // Forward the call to the defined proxy handler\n        return handler[trap].apply(this, arguments || [])\n      &#125; catch (err) &#123;\n        // Stack traces differ per browser, we only support chromium based ones currently\n        if (!err || !err.stack || !err.stack.includes(`at `)) &#123;\n          throw err\n        &#125;\n\n        // When something throws within one of our traps the Proxy will show up in error stacks\n        // An earlier implementation of this code would simply strip lines with a blacklist,\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\n        // We try to use a known \&quot;anchor\&quot; line for that and strip it with everything above it.\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\n\n        const stripWithBlacklist = (stack, stripFirstLine = true) =&gt; &#123;\n          const blacklist = [\n            `at Reflect.$&#123;trap&#125; `, // e.g. Reflect.get or Reflect.apply\n            `at Object.$&#123;trap&#125; `, // e.g. Object.get or Object.apply\n            `at Object.newHandler.&lt;computed&gt; [as $&#123;trap&#125;] ` // caused by this very wrapper :-)\n          ]\n          return (\n            err.stack\n              .split(&#x27;\\n&#x27;)\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\n              .filter((line, index) =&gt; !(index === 1 &amp;&amp; stripFirstLine))\n              // Check if the line starts with one of our blacklisted strings\n              .filter(line =&gt; !blacklist.some(bl =&gt; line.trim().startsWith(bl)))\n              .join(&#x27;\\n&#x27;)\n          )\n        &#125;\n\n        const stripWithAnchor = (stack, anchor) =&gt; &#123;\n          const stackArr = stack.split(&#x27;\\n&#x27;)\n          anchor = anchor || `at Object.newHandler.&lt;computed&gt; [as $&#123;trap&#125;] ` // Known first Proxy line in chromium\n          const anchorIndex = stackArr.findIndex(line =&gt;\n            line.trim().startsWith(anchor)\n          )\n          if (anchorIndex === -1) &#123;\n            return false // 404, anchor not found\n          &#125;\n          // Strip everything from the top until we reach the anchor line\n          // Note: We&#x27;re keeping the 1st line (zero index) as it&#x27;s unrelated (e.g. `TypeError`)\n          stackArr.splice(1, anchorIndex)\n          return stackArr.join(&#x27;\\n&#x27;)\n        &#125;\n\n        // Special cases due to our nested toString proxies\n        err.stack = err.stack.replace(\n          &#x27;at Object.toString (&#x27;,\n          &#x27;at Function.toString (&#x27;\n        )\n        if ((err.stack || &#x27;&#x27;).includes(&#x27;at Function.toString (&#x27;)) &#123;\n          err.stack = stripWithBlacklist(err.stack, false)\n          throw err\n        &#125;\n\n        // Try using the anchor method, fallback to blacklist if necessary\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\n\n        throw err // Re-throw our now sanitized error\n      &#125;\n    &#125;\n  &#125;)\n  return newHandler\n&#125;&quot;</span>,<span class="attr">stripErrorWithAnchor</span>:<span class="string">&quot;(err, anchor) =&gt; &#123;\n  const stackArr = err.stack.split(&#x27;\\n&#x27;)\n  const anchorIndex = stackArr.findIndex(line =&gt; line.trim().startsWith(anchor))\n  if (anchorIndex === -1) &#123;\n    return err // 404, anchor not found\n  &#125;\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\n  // Note: We&#x27;re keeping the 1st line (zero index) as it&#x27;s unrelated (e.g. `TypeError`)\n  stackArr.splice(1, anchorIndex)\n  err.stack = stackArr.join(&#x27;\\n&#x27;)\n  return err\n&#125;&quot;</span>,<span class="attr">replaceProperty</span>:<span class="string">&quot;(obj, propName, descriptorOverrides = &#123;&#125;) =&gt; &#123;\n  return Object.defineProperty(obj, propName, &#123;\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || &#123;&#125;),\n    // Add our overrides (e.g. value, get())\n    ...descriptorOverrides\n  &#125;)\n&#125;&quot;</span>,<span class="attr">preloadCache</span>:<span class="string">&quot;() =&gt; &#123;\n  if (utils.cache) &#123;\n    return\n  &#125;\n  utils.cache = &#123;\n    // Used in our proxies\n    Reflect: &#123;\n      get: Reflect.get.bind(Reflect),\n      apply: Reflect.apply.bind(Reflect)\n    &#125;,\n    // Used in `makeNativeString`\n    nativeToStringStr: Function.toString + &#x27;&#x27; // =&gt; `function toString() &#123; [native code] &#125;`\n  &#125;\n&#125;&quot;</span>,<span class="attr">makeNativeString</span>:<span class="string">&quot;(name = &#x27;&#x27;) =&gt; &#123;\n  return utils.cache.nativeToStringStr.replace(&#x27;toString&#x27;, name || &#x27;&#x27;)\n&#125;&quot;</span>,<span class="attr">patchToString</span>:<span class="string">&quot;(obj, str = &#x27;&#x27;) =&gt; &#123;\n  const handler = &#123;\n    apply: function (target, ctx) &#123;\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \&quot;\&quot;`\n      if (ctx === Function.prototype.toString) &#123;\n        return utils.makeNativeString(&#x27;toString&#x27;)\n      &#125;\n      // `toString` targeted at our proxied Object detected\n      if (ctx === obj) &#123;\n        // We either return the optional string verbatim or derive the most desired result automatically\n        return str || utils.makeNativeString(obj.name)\n      &#125;\n      // Check if the toString protype of the context is the same as the global prototype,\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\n      const hasSameProto = Object.getPrototypeOf(\n        Function.prototype.toString\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\n      if (!hasSameProto) &#123;\n        // Pass the call on to the local Function.prototype.toString instead\n        return ctx.toString()\n      &#125;\n      return target.call(ctx)\n    &#125;\n  &#125;\n\n  const toStringProxy = new Proxy(\n    Function.prototype.toString,\n    utils.stripProxyFromErrors(handler)\n  )\n  utils.replaceProperty(Function.prototype, &#x27;toString&#x27;, &#123;\n    value: toStringProxy\n  &#125;)\n&#125;&quot;</span>,<span class="attr">patchToStringNested</span>:<span class="string">&quot;(obj = &#123;&#125;) =&gt; &#123;\n  return utils.execRecursively(obj, [&#x27;function&#x27;], utils.patchToString)\n&#125;&quot;</span>,<span class="attr">redirectToString</span>:<span class="string">&quot;(proxyObj, originalObj) =&gt; &#123;\n  const handler = &#123;\n    apply: function (target, ctx) &#123;\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \&quot;\&quot;`\n      if (ctx === Function.prototype.toString) &#123;\n        return utils.makeNativeString(&#x27;toString&#x27;)\n      &#125;\n\n      // `toString` targeted at our proxied Object detected\n      if (ctx === proxyObj) &#123;\n        const fallback = () =&gt;\n          originalObj &amp;&amp; originalObj.name\n            ? utils.makeNativeString(originalObj.name)\n            : utils.makeNativeString(proxyObj.name)\n\n        // Return the toString representation of our original object if possible\n        return originalObj + &#x27;&#x27; || fallback()\n      &#125;\n\n      if (typeof ctx === &#x27;undefined&#x27; || ctx === null) &#123;\n        return target.call(ctx)\n      &#125;\n\n      // Check if the toString protype of the context is the same as the global prototype,\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\n      const hasSameProto = Object.getPrototypeOf(\n        Function.prototype.toString\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\n      if (!hasSameProto) &#123;\n        // Pass the call on to the local Function.prototype.toString instead\n        return ctx.toString()\n      &#125;\n\n      return target.call(ctx)\n    &#125;\n  &#125;\n\n  const toStringProxy = new Proxy(\n    Function.prototype.toString,\n    utils.stripProxyFromErrors(handler)\n  )\n  utils.replaceProperty(Function.prototype, &#x27;toString&#x27;, &#123;\n    value: toStringProxy\n  &#125;)\n&#125;&quot;</span>,<span class="attr">replaceWithProxy</span>:<span class="string">&quot;(obj, propName, handler) =&gt; &#123;\n  const originalObj = obj[propName]\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, &#123; value: proxyObj &#125;)\n  utils.redirectToString(proxyObj, originalObj)\n\n  return true\n&#125;&quot;</span>,<span class="attr">replaceGetterWithProxy</span>:<span class="string">&quot;(obj, propName, handler) =&gt; &#123;\n  const fn = Object.getOwnPropertyDescriptor(obj, propName).get\n  const fnStr = fn.toString() // special getter function string\n  const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, &#123; get: proxyObj &#125;)\n  utils.patchToString(proxyObj, fnStr)\n\n  return true\n&#125;&quot;</span>,<span class="attr">replaceGetterSetter</span>:<span class="string">&quot;(obj, propName, handlerGetterSetter) =&gt; &#123;\n  const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)\n  const handler = &#123; ...ownPropertyDescriptor &#125;\n\n  if (handlerGetterSetter.get !== undefined) &#123;\n    const nativeFn = ownPropertyDescriptor.get\n    handler.get = function() &#123;\n      return handlerGetterSetter.get.call(this, nativeFn.bind(this))\n    &#125;\n    utils.redirectToString(handler.get, nativeFn)\n  &#125;\n\n  if (handlerGetterSetter.set !== undefined) &#123;\n    const nativeFn = ownPropertyDescriptor.set\n    handler.set = function(newValue) &#123;\n      handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this))\n    &#125;\n    utils.redirectToString(handler.set, nativeFn)\n  &#125;\n\n  Object.defineProperty(obj, propName, handler)\n&#125;&quot;</span>,<span class="attr">mockWithProxy</span>:<span class="string">&quot;(obj, propName, pseudoTarget, handler) =&gt; &#123;\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, &#123; value: proxyObj &#125;)\n  utils.patchToString(proxyObj)\n\n  return true\n&#125;&quot;</span>,<span class="attr">createProxy</span>:<span class="string">&quot;(pseudoTarget, handler) =&gt; &#123;\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\n  utils.patchToString(proxyObj)\n\n  return proxyObj\n&#125;&quot;</span>,<span class="attr">splitObjPath</span>:<span class="string">&quot;objPath =&gt; (&#123;\n  // Remove last dot entry (property) ==&gt; `HTMLMediaElement.prototype`\n  objName: objPath.split(&#x27;.&#x27;).slice(0, -1).join(&#x27;.&#x27;),\n  // Extract last dot entry ==&gt; `canPlayType`\n  propName: objPath.split(&#x27;.&#x27;).slice(-1)[0]\n&#125;)&quot;</span>,<span class="attr">replaceObjPathWithProxy</span>:<span class="string">&quot;(objPath, handler) =&gt; &#123;\n  const &#123; objName, propName &#125; = utils.splitObjPath(objPath)\n  const obj = eval(objName) // eslint-disable-line no-eval\n  return utils.replaceWithProxy(obj, propName, handler)\n&#125;&quot;</span>,<span class="attr">execRecursively</span>:<span class="string">&quot;(obj = &#123;&#125;, typeFilter = [], fn) =&gt; &#123;\n  function recurse(obj) &#123;\n    for (const key in obj) &#123;\n      if (obj[key] === undefined) &#123;\n        continue\n      &#125;\n      if (obj[key] &amp;&amp; typeof obj[key] === &#x27;object&#x27;) &#123;\n        recurse(obj[key])\n      &#125; else &#123;\n        if (obj[key] &amp;&amp; typeFilter.includes(typeof obj[key])) &#123;\n          fn.call(this, obj[key])\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n  recurse(obj)\n  return obj\n&#125;&quot;</span>,<span class="attr">stringifyFns</span>:<span class="string">&quot;(fnObj = &#123; hello: () =&gt; &#x27;world&#x27; &#125;) =&gt; &#123;\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\n  // https://github.com/feross/fromentries\n  function fromEntries(iterable) &#123;\n    return [...iterable].reduce((obj, [key, val]) =&gt; &#123;\n      obj[key] = val\n      return obj\n    &#125;, &#123;&#125;)\n  &#125;\n  return (Object.fromEntries || fromEntries)(\n    Object.entries(fnObj)\n      .filter(([key, value]) =&gt; typeof value === &#x27;function&#x27;)\n      .map(([key, value]) =&gt; [key, value.toString()]) // eslint-disable-line no-eval\n  )\n&#125;&quot;</span>,<span class="attr">materializeFns</span>:<span class="string">&quot;(fnStrObj = &#123; hello: \&quot;() =&gt; &#x27;world&#x27;\&quot; &#125;) =&gt; &#123;\n  return Object.fromEntries(\n    Object.entries(fnStrObj).map(([key, value]) =&gt; &#123;\n      if (value.startsWith(&#x27;function&#x27;)) &#123;\n        // some trickery is needed to make oldschool functions work :-)\n        return [key, eval(`() =&gt; $&#123;value&#125;`)()] // eslint-disable-line no-eval\n      &#125; else &#123;\n        // arrow functions just work\n        return [key, eval(value)] // eslint-disable-line no-eval\n      &#125;\n    &#125;)\n  )\n&#125;&quot;</span>,<span class="attr">makeHandler</span>:<span class="string">&quot;() =&gt; (&#123;\n  // Used by simple `navigator` getter evasions\n  getterValue: value =&gt; (&#123;\n    apply(target, ctx, args) &#123;\n      // Let&#x27;s fetch the value first, to trigger and escalate potential errors\n      // Illegal invocations like `navigator.__proto__.vendor` will throw here\n      utils.cache.Reflect.apply(...arguments)\n      return value\n    &#125;\n  &#125;)\n&#125;)&quot;</span>,<span class="attr">arrayEquals</span>:<span class="string">&quot;(array1, array2) =&gt; &#123;\n  if (array1.length !== array2.length) &#123;\n    return false\n  &#125;\n  for (let i = 0; i &lt; array1.length; ++i) &#123;\n    if (array1[i] !== array2[i]) &#123;\n      return false\n    &#125;\n  &#125;\n  return true\n&#125;&quot;</span>,<span class="attr">memoize</span>:<span class="string">&quot;fn =&gt; &#123;\n  const cache = []\n  return function(...args) &#123;\n    if (!cache.some(c =&gt; utils.arrayEquals(c.key, args))) &#123;\n      cache.push(&#123; key: args, value: fn.apply(this, args) &#125;)\n    &#125;\n    return cache.find(c =&gt; utils.arrayEquals(c.key, args)).value\n  &#125;\n&#125;&quot;</span>&#125;,<span class="attr">_mainFunction</span>:<span class="string">&#x27;utils =&gt; &#123;\n      if (!window.chrome) &#123;\n        // Use the exact property descriptor found in headful Chrome\n        // fetch it via `Object.getOwnPropertyDescriptor(window, \&#x27;chrome\&#x27;)`\n        Object.defineProperty(window, \&#x27;chrome\&#x27;, &#123;\n          writable: true,\n          enumerable: true,\n          configurable: false, // note!\n          value: &#123;&#125; // We\&#x27;ll extend that later\n        &#125;)\n      &#125;\n\n      // That means we\&#x27;re running headful and don\&#x27;t need to mock anything\n      if (\&#x27;app\&#x27; in window.chrome) &#123;\n        return // Nothing to do here\n      &#125;\n\n      const makeError = &#123;\n        ErrorInInvocation: fn =&gt; &#123;\n          const err = new TypeError(`Error in invocation of app.$&#123;fn&#125;()`)\n          return utils.stripErrorWithAnchor(\n            err,\n            `at $&#123;fn&#125; (eval at &lt;anonymous&gt;`\n          )\n        &#125;\n      &#125;\n\n      // There\&#x27;s a some static data in that property which doesn\&#x27;t seem to change,\n      // we should periodically check for updates: `JSON.stringify(window.app, null, 2)`\n      const STATIC_DATA = JSON.parse(\n        `\n&#123;\n  &quot;isInstalled&quot;: false,\n  &quot;InstallState&quot;: &#123;\n    &quot;DISABLED&quot;: &quot;disabled&quot;,\n    &quot;INSTALLED&quot;: &quot;installed&quot;,\n    &quot;NOT_INSTALLED&quot;: &quot;not_installed&quot;\n  &#125;,\n  &quot;RunningState&quot;: &#123;\n    &quot;CANNOT_RUN&quot;: &quot;cannot_run&quot;,\n    &quot;READY_TO_RUN&quot;: &quot;ready_to_run&quot;,\n    &quot;RUNNING&quot;: &quot;running&quot;\n  &#125;\n&#125;\n        `.trim()\n      )\n\n      window.chrome.app = &#123;\n        ...STATIC_DATA,\n\n        get isInstalled() &#123;\n          return false\n        &#125;,\n\n        getDetails: function getDetails() &#123;\n          if (arguments.length) &#123;\n            throw makeError.ErrorInInvocation(`getDetails`)\n          &#125;\n          return null\n        &#125;,\n        getIsInstalled: function getDetails() &#123;\n          if (arguments.length) &#123;\n            throw makeError.ErrorInInvocation(`getIsInstalled`)\n          &#125;\n          return false\n        &#125;,\n        runningState: function getDetails() &#123;\n          if (arguments.length) &#123;\n            throw makeError.ErrorInInvocation(`runningState`)\n          &#125;\n          return \&#x27;cannot_run\&#x27;\n        &#125;\n      &#125;\n      utils.patchToStringNested(window.chrome.app)\n    &#125;&#x27;</span>,<span class="attr">_args</span>:[]&#125;),(<span class="function">(<span class="params">&#123;_utilsFns:_utilsFns,_mainFunction:_mainFunction,_args:_args&#125;</span>)=&gt;</span>&#123;<span class="keyword">const</span> utils=<span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(_utilsFns).<span class="title function_">map</span>((<span class="function">(<span class="params">[key,value]</span>)=&gt;</span>[key,<span class="built_in">eval</span>(value)])));utils.<span class="title function_">init</span>(),<span class="built_in">eval</span>(_mainFunction)(utils,..._args)&#125;)(&#123;<span class="attr">_utilsFns</span>:&#123;<span class="attr">init</span>:<span class="string">&quot;() =&gt; &#123;\n  utils.preloadCache()\n&#125;&quot;</span>,<span class="attr">stripProxyFromErrors</span>:<span class="string">&quot;(handler = &#123;&#125;) =&gt; &#123;\n  const newHandler = &#123;\n    setPrototypeOf: function (target, proto) &#123;\n      if (proto === null)\n        throw new TypeError(&#x27;Cannot convert object to primitive value&#x27;)\n      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) &#123;\n        throw new TypeError(&#x27;Cyclic __proto__ value&#x27;)\n      &#125;\n      return Reflect.setPrototypeOf(target, proto)\n    &#125;\n  &#125;\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\n  const traps = Object.getOwnPropertyNames(handler)\n  traps.forEach(trap =&gt; &#123;\n    newHandler[trap] = function () &#123;\n      try &#123;\n        // Forward the call to the defined proxy handler\n        return handler[trap].apply(this, arguments || [])\n      &#125; catch (err) &#123;\n        // Stack traces differ per browser, we only support chromium based ones currently\n        if (!err || !err.stack || !err.stack.includes(`at `)) &#123;\n          throw err\n        &#125;\n\n        // When something throws within one of our traps the Proxy will show up in error stacks\n        // An earlier implementation of this code would simply strip lines with a blacklist,\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\n        // We try to use a known \&quot;anchor\&quot; line for that and strip it with everything above it.\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\n\n        const stripWithBlacklist = (stack, stripFirstLine = true) =&gt; &#123;\n          const blacklist = [\n            `at Reflect.$&#123;trap&#125; `, // e.g. Reflect.get or Reflect.apply\n            `at Object.$&#123;trap&#125; `, // e.g. Object.get or Object.apply\n            `at Object.newHandler.&lt;computed&gt; [as $&#123;trap&#125;] ` // caused by this very wrapper :-)\n          ]\n          return (\n            err.stack\n              .split(&#x27;\\n&#x27;)\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\n              .filter((line, index) =&gt; !(index === 1 &amp;&amp; stripFirstLine))\n              // Check if the line starts with one of our blacklisted strings\n              .filter(line =&gt; !blacklist.some(bl =&gt; line.trim().startsWith(bl)))\n              .join(&#x27;\\n&#x27;)\n          )\n        &#125;\n\n        const stripWithAnchor = (stack, anchor) =&gt; &#123;\n          const stackArr = stack.split(&#x27;\\n&#x27;)\n          anchor = anchor || `at Object.newHandler.&lt;computed&gt; [as $&#123;trap&#125;] ` // Known first Proxy line in chromium\n          const anchorIndex = stackArr.findIndex(line =&gt;\n            line.trim().startsWith(anchor)\n          )\n          if (anchorIndex === -1) &#123;\n            return false // 404, anchor not found\n          &#125;\n          // Strip everything from the top until we reach the anchor line\n          // Note: We&#x27;re keeping the 1st line (zero index) as it&#x27;s unrelated (e.g. `TypeError`)\n          stackArr.splice(1, anchorIndex)\n          return stackArr.join(&#x27;\\n&#x27;)\n        &#125;\n\n        // Special cases due to our nested toString proxies\n        err.stack = err.stack.replace(\n          &#x27;at Object.toString (&#x27;,\n          &#x27;at Function.toString (&#x27;\n        )\n        if ((err.stack || &#x27;&#x27;).includes(&#x27;at Function.toString (&#x27;)) &#123;\n          err.stack = stripWithBlacklist(err.stack, false)\n          throw err\n        &#125;\n\n        // Try using the anchor method, fallback to blacklist if necessary\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\n\n        throw err // Re-throw our now sanitized error\n      &#125;\n    &#125;\n  &#125;)\n  return newHandler\n&#125;&quot;</span>,<span class="attr">stripErrorWithAnchor</span>:<span class="string">&quot;(err, anchor) =&gt; &#123;\n  const stackArr = err.stack.split(&#x27;\\n&#x27;)\n  const anchorIndex = stackArr.findIndex(line =&gt; line.trim().startsWith(anchor))\n  if (anchorIndex === -1) &#123;\n    return err // 404, anchor not found\n  &#125;\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\n  // Note: We&#x27;re keeping the 1st line (zero index) as it&#x27;s unrelated (e.g. `TypeError`)\n  stackArr.splice(1, anchorIndex)\n  err.stack = stackArr.join(&#x27;\\n&#x27;)\n  return err\n&#125;&quot;</span>,<span class="attr">replaceProperty</span>:<span class="string">&quot;(obj, propName, descriptorOverrides = &#123;&#125;) =&gt; &#123;\n  return Object.defineProperty(obj, propName, &#123;\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || &#123;&#125;),\n    // Add our overrides (e.g. value, get())\n    ...descriptorOverrides\n  &#125;)\n&#125;&quot;</span>,<span class="attr">preloadCache</span>:<span class="string">&quot;() =&gt; &#123;\n  if (utils.cache) &#123;\n    return\n  &#125;\n  utils.cache = &#123;\n    // Used in our proxies\n    Reflect: &#123;\n      get: Reflect.get.bind(Reflect),\n      apply: Reflect.apply.bind(Reflect)\n    &#125;,\n    // Used in `makeNativeString`\n    nativeToStringStr: Function.toString + &#x27;&#x27; // =&gt; `function toString() &#123; [native code] &#125;`\n  &#125;\n&#125;&quot;</span>,<span class="attr">makeNativeString</span>:<span class="string">&quot;(name = &#x27;&#x27;) =&gt; &#123;\n  return utils.cache.nativeToStringStr.replace(&#x27;toString&#x27;, name || &#x27;&#x27;)\n&#125;&quot;</span>,<span class="attr">patchToString</span>:<span class="string">&quot;(obj, str = &#x27;&#x27;) =&gt; &#123;\n  const handler = &#123;\n    apply: function (target, ctx) &#123;\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \&quot;\&quot;`\n      if (ctx === Function.prototype.toString) &#123;\n        return utils.makeNativeString(&#x27;toString&#x27;)\n      &#125;\n      // `toString` targeted at our proxied Object detected\n      if (ctx === obj) &#123;\n        // We either return the optional string verbatim or derive the most desired result automatically\n        return str || utils.makeNativeString(obj.name)\n      &#125;\n      // Check if the toString protype of the context is the same as the global prototype,\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\n      const hasSameProto = Object.getPrototypeOf(\n        Function.prototype.toString\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\n      if (!hasSameProto) &#123;\n        // Pass the call on to the local Function.prototype.toString instead\n        return ctx.toString()\n      &#125;\n      return target.call(ctx)\n    &#125;\n  &#125;\n\n  const toStringProxy = new Proxy(\n    Function.prototype.toString,\n    utils.stripProxyFromErrors(handler)\n  )\n  utils.replaceProperty(Function.prototype, &#x27;toString&#x27;, &#123;\n    value: toStringProxy\n  &#125;)\n&#125;&quot;</span>,<span class="attr">patchToStringNested</span>:<span class="string">&quot;(obj = &#123;&#125;) =&gt; &#123;\n  return utils.execRecursively(obj, [&#x27;function&#x27;], utils.patchToString)\n&#125;&quot;</span>,<span class="attr">redirectToString</span>:<span class="string">&quot;(proxyObj, originalObj) =&gt; &#123;\n  const handler = &#123;\n    apply: function (target, ctx) &#123;\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \&quot;\&quot;`\n      if (ctx === Function.prototype.toString) &#123;\n        return utils.makeNativeString(&#x27;toString&#x27;)\n      &#125;\n\n      // `toString` targeted at our proxied Object detected\n      if (ctx === proxyObj) &#123;\n        const fallback = () =&gt;\n          originalObj &amp;&amp; originalObj.name\n            ? utils.makeNativeString(originalObj.name)\n            : utils.makeNativeString(proxyObj.name)\n\n        // Return the toString representation of our original object if possible\n        return originalObj + &#x27;&#x27; || fallback()\n      &#125;\n\n      if (typeof ctx === &#x27;undefined&#x27; || ctx === null) &#123;\n        return target.call(ctx)\n      &#125;\n\n      // Check if the toString protype of the context is the same as the global prototype,\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\n      const hasSameProto = Object.getPrototypeOf(\n        Function.prototype.toString\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\n      if (!hasSameProto) &#123;\n        // Pass the call on to the local Function.prototype.toString instead\n        return ctx.toString()\n      &#125;\n\n      return target.call(ctx)\n    &#125;\n  &#125;\n\n  const toStringProxy = new Proxy(\n    Function.prototype.toString,\n    utils.stripProxyFromErrors(handler)\n  )\n  utils.replaceProperty(Function.prototype, &#x27;toString&#x27;, &#123;\n    value: toStringProxy\n  &#125;)\n&#125;&quot;</span>,<span class="attr">replaceWithProxy</span>:<span class="string">&quot;(obj, propName, handler) =&gt; &#123;\n  const originalObj = obj[propName]\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, &#123; value: proxyObj &#125;)\n  utils.redirectToString(proxyObj, originalObj)\n\n  return true\n&#125;&quot;</span>,<span class="attr">replaceGetterWithProxy</span>:<span class="string">&quot;(obj, propName, handler) =&gt; &#123;\n  const fn = Object.getOwnPropertyDescriptor(obj, propName).get\n  const fnStr = fn.toString() // special getter function string\n  const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, &#123; get: proxyObj &#125;)\n  utils.patchToString(proxyObj, fnStr)\n\n  return true\n&#125;&quot;</span>,<span class="attr">replaceGetterSetter</span>:<span class="string">&quot;(obj, propName, handlerGetterSetter) =&gt; &#123;\n  const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)\n  const handler = &#123; ...ownPropertyDescriptor &#125;\n\n  if (handlerGetterSetter.get !== undefined) &#123;\n    const nativeFn = ownPropertyDescriptor.get\n    handler.get = function() &#123;\n      return handlerGetterSetter.get.call(this, nativeFn.bind(this))\n    &#125;\n    utils.redirectToString(handler.get, nativeFn)\n  &#125;\n\n  if (handlerGetterSetter.set !== undefined) &#123;\n    const nativeFn = ownPropertyDescriptor.set\n    handler.set = function(newValue) &#123;\n      handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this))\n    &#125;\n    utils.redirectToString(handler.set, nativeFn)\n  &#125;\n\n  Object.defineProperty(obj, propName, handler)\n&#125;&quot;</span>,<span class="attr">mockWithProxy</span>:<span class="string">&quot;(obj, propName, pseudoTarget, handler) =&gt; &#123;\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, &#123; value: proxyObj &#125;)\n  utils.patchToString(proxyObj)\n\n  return true\n&#125;&quot;</span>,<span class="attr">createProxy</span>:<span class="string">&quot;(pseudoTarget, handler) =&gt; &#123;\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\n  utils.patchToString(proxyObj)\n\n  return proxyObj\n&#125;&quot;</span>,<span class="attr">splitObjPath</span>:<span class="string">&quot;objPath =&gt; (&#123;\n  // Remove last dot entry (property) ==&gt; `HTMLMediaElement.prototype`\n  objName: objPath.split(&#x27;.&#x27;).slice(0, -1).join(&#x27;.&#x27;),\n  // Extract last dot entry ==&gt; `canPlayType`\n  propName: objPath.split(&#x27;.&#x27;).slice(-1)[0]\n&#125;)&quot;</span>,<span class="attr">replaceObjPathWithProxy</span>:<span class="string">&quot;(objPath, handler) =&gt; &#123;\n  const &#123; objName, propName &#125; = utils.splitObjPath(objPath)\n  const obj = eval(objName) // eslint-disable-line no-eval\n  return utils.replaceWithProxy(obj, propName, handler)\n&#125;&quot;</span>,<span class="attr">execRecursively</span>:<span class="string">&quot;(obj = &#123;&#125;, typeFilter = [], fn) =&gt; &#123;\n  function recurse(obj) &#123;\n    for (const key in obj) &#123;\n      if (obj[key] === undefined) &#123;\n        continue\n      &#125;\n      if (obj[key] &amp;&amp; typeof obj[key] === &#x27;object&#x27;) &#123;\n        recurse(obj[key])\n      &#125; else &#123;\n        if (obj[key] &amp;&amp; typeFilter.includes(typeof obj[key])) &#123;\n          fn.call(this, obj[key])\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n  recurse(obj)\n  return obj\n&#125;&quot;</span>,<span class="attr">stringifyFns</span>:<span class="string">&quot;(fnObj = &#123; hello: () =&gt; &#x27;world&#x27; &#125;) =&gt; &#123;\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\n  // https://github.com/feross/fromentries\n  function fromEntries(iterable) &#123;\n    return [...iterable].reduce((obj, [key, val]) =&gt; &#123;\n      obj[key] = val\n      return obj\n    &#125;, &#123;&#125;)\n  &#125;\n  return (Object.fromEntries || fromEntries)(\n    Object.entries(fnObj)\n      .filter(([key, value]) =&gt; typeof value === &#x27;function&#x27;)\n      .map(([key, value]) =&gt; [key, value.toString()]) // eslint-disable-line no-eval\n  )\n&#125;&quot;</span>,<span class="attr">materializeFns</span>:<span class="string">&quot;(fnStrObj = &#123; hello: \&quot;() =&gt; &#x27;world&#x27;\&quot; &#125;) =&gt; &#123;\n  return Object.fromEntries(\n    Object.entries(fnStrObj).map(([key, value]) =&gt; &#123;\n      if (value.startsWith(&#x27;function&#x27;)) &#123;\n        // some trickery is needed to make oldschool functions work :-)\n        return [key, eval(`() =&gt; $&#123;value&#125;`)()] // eslint-disable-line no-eval\n      &#125; else &#123;\n        // arrow functions just work\n        return [key, eval(value)] // eslint-disable-line no-eval\n      &#125;\n    &#125;)\n  )\n&#125;&quot;</span>,<span class="attr">makeHandler</span>:<span class="string">&quot;() =&gt; (&#123;\n  // Used by simple `navigator` getter evasions\n  getterValue: value =&gt; (&#123;\n    apply(target, ctx, args) &#123;\n      // Let&#x27;s fetch the value first, to trigger and escalate potential errors\n      // Illegal invocations like `navigator.__proto__.vendor` will throw here\n      utils.cache.Reflect.apply(...arguments)\n      return value\n    &#125;\n  &#125;)\n&#125;)&quot;</span>,<span class="attr">arrayEquals</span>:<span class="string">&quot;(array1, array2) =&gt; &#123;\n  if (array1.length !== array2.length) &#123;\n    return false\n  &#125;\n  for (let i = 0; i &lt; array1.length; ++i) &#123;\n    if (array1[i] !== array2[i]) &#123;\n      return false\n    &#125;\n  &#125;\n  return true\n&#125;&quot;</span>,<span class="attr">memoize</span>:<span class="string">&quot;fn =&gt; &#123;\n  const cache = []\n  return function(...args) &#123;\n    if (!cache.some(c =&gt; utils.arrayEquals(c.key, args))) &#123;\n      cache.push(&#123; key: args, value: fn.apply(this, args) &#125;)\n    &#125;\n    return cache.find(c =&gt; utils.arrayEquals(c.key, args)).value\n  &#125;\n&#125;&quot;</span>&#125;,<span class="attr">_mainFunction</span>:<span class="string">&quot;utils =&gt; &#123;\n      if (!window.chrome) &#123;\n        // Use the exact property descriptor found in headful Chrome\n        // fetch it via `Object.getOwnPropertyDescriptor(window, &#x27;chrome&#x27;)`\n        Object.defineProperty(window, &#x27;chrome&#x27;, &#123;\n          writable: true,\n          enumerable: true,\n          configurable: false, // note!\n          value: &#123;&#125; // We&#x27;ll extend that later\n        &#125;)\n      &#125;\n\n      // That means we&#x27;re running headful and don&#x27;t need to mock anything\n      if (&#x27;csi&#x27; in window.chrome) &#123;\n        return // Nothing to do here\n      &#125;\n\n      // Check that the Navigation Timing API v1 is available, we need that\n      if (!window.performance || !window.performance.timing) &#123;\n        return\n      &#125;\n\n      const &#123; timing &#125; = window.performance\n\n      window.chrome.csi = function() &#123;\n        return &#123;\n          onloadT: timing.domContentLoadedEventEnd,\n          startE: timing.navigationStart,\n          pageT: Date.now() - timing.navigationStart,\n          tran: 15 // Transition type or something\n        &#125;\n      &#125;\n      utils.patchToString(window.chrome.csi)\n    &#125;&quot;</span>,<span class="attr">_args</span>:[]&#125;),(<span class="function">(<span class="params">&#123;_utilsFns:_utilsFns,_mainFunction:_mainFunction,_args:_args&#125;</span>)=&gt;</span>&#123;<span class="keyword">const</span> utils=<span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(_utilsFns).<span class="title function_">map</span>((<span class="function">(<span class="params">[key,value]</span>)=&gt;</span>[key,<span class="built_in">eval</span>(value)])));utils.<span class="title function_">init</span>(),<span class="built_in">eval</span>(_mainFunction)(utils,..._args)&#125;)(&#123;<span class="attr">_utilsFns</span>:&#123;<span class="attr">init</span>:<span class="string">&quot;() =&gt; &#123;\n  utils.preloadCache()\n&#125;&quot;</span>,<span class="attr">stripProxyFromErrors</span>:<span class="string">&quot;(handler = &#123;&#125;) =&gt; &#123;\n  const newHandler = &#123;\n    setPrototypeOf: function (target, proto) &#123;\n      if (proto === null)\n        throw new TypeError(&#x27;Cannot convert object to primitive value&#x27;)\n      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) &#123;\n        throw new TypeError(&#x27;Cyclic __proto__ value&#x27;)\n      &#125;\n      return Reflect.setPrototypeOf(target, proto)\n    &#125;\n  &#125;\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\n  const traps = Object.getOwnPropertyNames(handler)\n  traps.forEach(trap =&gt; &#123;\n    newHandler[trap] = function () &#123;\n      try &#123;\n        // Forward the call to the defined proxy handler\n        return handler[trap].apply(this, arguments || [])\n      &#125; catch (err) &#123;\n        // Stack traces differ per browser, we only support chromium based ones currently\n        if (!err || !err.stack || !err.stack.includes(`at `)) &#123;\n          throw err\n        &#125;\n\n        // When something throws within one of our traps the Proxy will show up in error stacks\n        // An earlier implementation of this code would simply strip lines with a blacklist,\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\n        // We try to use a known \&quot;anchor\&quot; line for that and strip it with everything above it.\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\n\n        const stripWithBlacklist = (stack, stripFirstLine = true) =&gt; &#123;\n          const blacklist = [\n            `at Reflect.$&#123;trap&#125; `, // e.g. Reflect.get or Reflect.apply\n            `at Object.$&#123;trap&#125; `, // e.g. Object.get or Object.apply\n            `at Object.newHandler.&lt;computed&gt; [as $&#123;trap&#125;] ` // caused by this very wrapper :-)\n          ]\n          return (\n            err.stack\n              .split(&#x27;\\n&#x27;)\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\n              .filter((line, index) =&gt; !(index === 1 &amp;&amp; stripFirstLine))\n              // Check if the line starts with one of our blacklisted strings\n              .filter(line =&gt; !blacklist.some(bl =&gt; line.trim().startsWith(bl)))\n              .join(&#x27;\\n&#x27;)\n          )\n        &#125;\n\n        const stripWithAnchor = (stack, anchor) =&gt; &#123;\n          const stackArr = stack.split(&#x27;\\n&#x27;)\n          anchor = anchor || `at Object.newHandler.&lt;computed&gt; [as $&#123;trap&#125;] ` // Known first Proxy line in chromium\n          const anchorIndex = stackArr.findIndex(line =&gt;\n            line.trim().startsWith(anchor)\n          )\n          if (anchorIndex === -1) &#123;\n            return false // 404, anchor not found\n          &#125;\n          // Strip everything from the top until we reach the anchor line\n          // Note: We&#x27;re keeping the 1st line (zero index) as it&#x27;s unrelated (e.g. `TypeError`)\n          stackArr.splice(1, anchorIndex)\n          return stackArr.join(&#x27;\\n&#x27;)\n        &#125;\n\n        // Special cases due to our nested toString proxies\n        err.stack = err.stack.replace(\n          &#x27;at Object.toString (&#x27;,\n          &#x27;at Function.toString (&#x27;\n        )\n        if ((err.stack || &#x27;&#x27;).includes(&#x27;at Function.toString (&#x27;)) &#123;\n          err.stack = stripWithBlacklist(err.stack, false)\n          throw err\n        &#125;\n\n        // Try using the anchor method, fallback to blacklist if necessary\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\n\n        throw err // Re-throw our now sanitized error\n      &#125;\n    &#125;\n  &#125;)\n  return newHandler\n&#125;&quot;</span>,<span class="attr">stripErrorWithAnchor</span>:<span class="string">&quot;(err, anchor) =&gt; &#123;\n  const stackArr = err.stack.split(&#x27;\\n&#x27;)\n  const anchorIndex = stackArr.findIndex(line =&gt; line.trim().startsWith(anchor))\n  if (anchorIndex === -1) &#123;\n    return err // 404, anchor not found\n  &#125;\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\n  // Note: We&#x27;re keeping the 1st line (zero index) as it&#x27;s unrelated (e.g. `TypeError`)\n  stackArr.splice(1, anchorIndex)\n  err.stack = stackArr.join(&#x27;\\n&#x27;)\n  return err\n&#125;&quot;</span>,<span class="attr">replaceProperty</span>:<span class="string">&quot;(obj, propName, descriptorOverrides = &#123;&#125;) =&gt; &#123;\n  return Object.defineProperty(obj, propName, &#123;\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || &#123;&#125;),\n    // Add our overrides (e.g. value, get())\n    ...descriptorOverrides\n  &#125;)\n&#125;&quot;</span>,<span class="attr">preloadCache</span>:<span class="string">&quot;() =&gt; &#123;\n  if (utils.cache) &#123;\n    return\n  &#125;\n  utils.cache = &#123;\n    // Used in our proxies\n    Reflect: &#123;\n      get: Reflect.get.bind(Reflect),\n      apply: Reflect.apply.bind(Reflect)\n    &#125;,\n    // Used in `makeNativeString`\n    nativeToStringStr: Function.toString + &#x27;&#x27; // =&gt; `function toString() &#123; [native code] &#125;`\n  &#125;\n&#125;&quot;</span>,<span class="attr">makeNativeString</span>:<span class="string">&quot;(name = &#x27;&#x27;) =&gt; &#123;\n  return utils.cache.nativeToStringStr.replace(&#x27;toString&#x27;, name || &#x27;&#x27;)\n&#125;&quot;</span>,<span class="attr">patchToString</span>:<span class="string">&quot;(obj, str = &#x27;&#x27;) =&gt; &#123;\n  const handler = &#123;\n    apply: function (target, ctx) &#123;\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \&quot;\&quot;`\n      if (ctx === Function.prototype.toString) &#123;\n        return utils.makeNativeString(&#x27;toString&#x27;)\n      &#125;\n      // `toString` targeted at our proxied Object detected\n      if (ctx === obj) &#123;\n        // We either return the optional string verbatim or derive the most desired result automatically\n        return str || utils.makeNativeString(obj.name)\n      &#125;\n      // Check if the toString protype of the context is the same as the global prototype,\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\n      const hasSameProto = Object.getPrototypeOf(\n        Function.prototype.toString\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\n      if (!hasSameProto) &#123;\n        // Pass the call on to the local Function.prototype.toString instead\n        return ctx.toString()\n      &#125;\n      return target.call(ctx)\n    &#125;\n  &#125;\n\n  const toStringProxy = new Proxy(\n    Function.prototype.toString,\n    utils.stripProxyFromErrors(handler)\n  )\n  utils.replaceProperty(Function.prototype, &#x27;toString&#x27;, &#123;\n    value: toStringProxy\n  &#125;)\n&#125;&quot;</span>,<span class="attr">patchToStringNested</span>:<span class="string">&quot;(obj = &#123;&#125;) =&gt; &#123;\n  return utils.execRecursively(obj, [&#x27;function&#x27;], utils.patchToString)\n&#125;&quot;</span>,<span class="attr">redirectToString</span>:<span class="string">&quot;(proxyObj, originalObj) =&gt; &#123;\n  const handler = &#123;\n    apply: function (target, ctx) &#123;\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \&quot;\&quot;`\n      if (ctx === Function.prototype.toString) &#123;\n        return utils.makeNativeString(&#x27;toString&#x27;)\n      &#125;\n\n      // `toString` targeted at our proxied Object detected\n      if (ctx === proxyObj) &#123;\n        const fallback = () =&gt;\n          originalObj &amp;&amp; originalObj.name\n            ? utils.makeNativeString(originalObj.name)\n            : utils.makeNativeString(proxyObj.name)\n\n        // Return the toString representation of our original object if possible\n        return originalObj + &#x27;&#x27; || fallback()\n      &#125;\n\n      if (typeof ctx === &#x27;undefined&#x27; || ctx === null) &#123;\n        return target.call(ctx)\n      &#125;\n\n      // Check if the toString protype of the context is the same as the global prototype,\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\n      const hasSameProto = Object.getPrototypeOf(\n        Function.prototype.toString\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\n      if (!hasSameProto) &#123;\n        // Pass the call on to the local Function.prototype.toString instead\n        return ctx.toString()\n      &#125;\n\n      return target.call(ctx)\n    &#125;\n  &#125;\n\n  const toStringProxy = new Proxy(\n    Function.prototype.toString,\n    utils.stripProxyFromErrors(handler)\n  )\n  utils.replaceProperty(Function.prototype, &#x27;toString&#x27;, &#123;\n    value: toStringProxy\n  &#125;)\n&#125;&quot;</span>,<span class="attr">replaceWithProxy</span>:<span class="string">&quot;(obj, propName, handler) =&gt; &#123;\n  const originalObj = obj[propName]\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, &#123; value: proxyObj &#125;)\n  utils.redirectToString(proxyObj, originalObj)\n\n  return true\n&#125;&quot;</span>,<span class="attr">replaceGetterWithProxy</span>:<span class="string">&quot;(obj, propName, handler) =&gt; &#123;\n  const fn = Object.getOwnPropertyDescriptor(obj, propName).get\n  const fnStr = fn.toString() // special getter function string\n  const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, &#123; get: proxyObj &#125;)\n  utils.patchToString(proxyObj, fnStr)\n\n  return true\n&#125;&quot;</span>,<span class="attr">replaceGetterSetter</span>:<span class="string">&quot;(obj, propName, handlerGetterSetter) =&gt; &#123;\n  const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)\n  const handler = &#123; ...ownPropertyDescriptor &#125;\n\n  if (handlerGetterSetter.get !== undefined) &#123;\n    const nativeFn = ownPropertyDescriptor.get\n    handler.get = function() &#123;\n      return handlerGetterSetter.get.call(this, nativeFn.bind(this))\n    &#125;\n    utils.redirectToString(handler.get, nativeFn)\n  &#125;\n\n  if (handlerGetterSetter.set !== undefined) &#123;\n    const nativeFn = ownPropertyDescriptor.set\n    handler.set = function(newValue) &#123;\n      handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this))\n    &#125;\n    utils.redirectToString(handler.set, nativeFn)\n  &#125;\n\n  Object.defineProperty(obj, propName, handler)\n&#125;&quot;</span>,<span class="attr">mockWithProxy</span>:<span class="string">&quot;(obj, propName, pseudoTarget, handler) =&gt; &#123;\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, &#123; value: proxyObj &#125;)\n  utils.patchToString(proxyObj)\n\n  return true\n&#125;&quot;</span>,<span class="attr">createProxy</span>:<span class="string">&quot;(pseudoTarget, handler) =&gt; &#123;\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\n  utils.patchToString(proxyObj)\n\n  return proxyObj\n&#125;&quot;</span>,<span class="attr">splitObjPath</span>:<span class="string">&quot;objPath =&gt; (&#123;\n  // Remove last dot entry (property) ==&gt; `HTMLMediaElement.prototype`\n  objName: objPath.split(&#x27;.&#x27;).slice(0, -1).join(&#x27;.&#x27;),\n  // Extract last dot entry ==&gt; `canPlayType`\n  propName: objPath.split(&#x27;.&#x27;).slice(-1)[0]\n&#125;)&quot;</span>,<span class="attr">replaceObjPathWithProxy</span>:<span class="string">&quot;(objPath, handler) =&gt; &#123;\n  const &#123; objName, propName &#125; = utils.splitObjPath(objPath)\n  const obj = eval(objName) // eslint-disable-line no-eval\n  return utils.replaceWithProxy(obj, propName, handler)\n&#125;&quot;</span>,<span class="attr">execRecursively</span>:<span class="string">&quot;(obj = &#123;&#125;, typeFilter = [], fn) =&gt; &#123;\n  function recurse(obj) &#123;\n    for (const key in obj) &#123;\n      if (obj[key] === undefined) &#123;\n        continue\n      &#125;\n      if (obj[key] &amp;&amp; typeof obj[key] === &#x27;object&#x27;) &#123;\n        recurse(obj[key])\n      &#125; else &#123;\n        if (obj[key] &amp;&amp; typeFilter.includes(typeof obj[key])) &#123;\n          fn.call(this, obj[key])\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n  recurse(obj)\n  return obj\n&#125;&quot;</span>,<span class="attr">stringifyFns</span>:<span class="string">&quot;(fnObj = &#123; hello: () =&gt; &#x27;world&#x27; &#125;) =&gt; &#123;\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\n  // https://github.com/feross/fromentries\n  function fromEntries(iterable) &#123;\n    return [...iterable].reduce((obj, [key, val]) =&gt; &#123;\n      obj[key] = val\n      return obj\n    &#125;, &#123;&#125;)\n  &#125;\n  return (Object.fromEntries || fromEntries)(\n    Object.entries(fnObj)\n      .filter(([key, value]) =&gt; typeof value === &#x27;function&#x27;)\n      .map(([key, value]) =&gt; [key, value.toString()]) // eslint-disable-line no-eval\n  )\n&#125;&quot;</span>,<span class="attr">materializeFns</span>:<span class="string">&quot;(fnStrObj = &#123; hello: \&quot;() =&gt; &#x27;world&#x27;\&quot; &#125;) =&gt; &#123;\n  return Object.fromEntries(\n    Object.entries(fnStrObj).map(([key, value]) =&gt; &#123;\n      if (value.startsWith(&#x27;function&#x27;)) &#123;\n        // some trickery is needed to make oldschool functions work :-)\n        return [key, eval(`() =&gt; $&#123;value&#125;`)()] // eslint-disable-line no-eval\n      &#125; else &#123;\n        // arrow functions just work\n        return [key, eval(value)] // eslint-disable-line no-eval\n      &#125;\n    &#125;)\n  )\n&#125;&quot;</span>,<span class="attr">makeHandler</span>:<span class="string">&quot;() =&gt; (&#123;\n  // Used by simple `navigator` getter evasions\n  getterValue: value =&gt; (&#123;\n    apply(target, ctx, args) &#123;\n      // Let&#x27;s fetch the value first, to trigger and escalate potential errors\n      // Illegal invocations like `navigator.__proto__.vendor` will throw here\n      utils.cache.Reflect.apply(...arguments)\n      return value\n    &#125;\n  &#125;)\n&#125;)&quot;</span>,<span class="attr">arrayEquals</span>:<span class="string">&quot;(array1, array2) =&gt; &#123;\n  if (array1.length !== array2.length) &#123;\n    return false\n  &#125;\n  for (let i = 0; i &lt; array1.length; ++i) &#123;\n    if (array1[i] !== array2[i]) &#123;\n      return false\n    &#125;\n  &#125;\n  return true\n&#125;&quot;</span>,<span class="attr">memoize</span>:<span class="string">&quot;fn =&gt; &#123;\n  const cache = []\n  return function(...args) &#123;\n    if (!cache.some(c =&gt; utils.arrayEquals(c.key, args))) &#123;\n      cache.push(&#123; key: args, value: fn.apply(this, args) &#125;)\n    &#125;\n    return cache.find(c =&gt; utils.arrayEquals(c.key, args)).value\n  &#125;\n&#125;&quot;</span>&#125;,<span class="attr">_mainFunction</span>:<span class="string">&quot;(utils, &#123; opts &#125;) =&gt; &#123;\n        if (!window.chrome) &#123;\n          // Use the exact property descriptor found in headful Chrome\n          // fetch it via `Object.getOwnPropertyDescriptor(window, &#x27;chrome&#x27;)`\n          Object.defineProperty(window, &#x27;chrome&#x27;, &#123;\n            writable: true,\n            enumerable: true,\n            configurable: false, // note!\n            value: &#123;&#125; // We&#x27;ll extend that later\n          &#125;)\n        &#125;\n\n        // That means we&#x27;re running headful and don&#x27;t need to mock anything\n        if (&#x27;loadTimes&#x27; in window.chrome) &#123;\n          return // Nothing to do here\n        &#125;\n\n        // Check that the Navigation Timing API v1 + v2 is available, we need that\n        if (\n          !window.performance ||\n          !window.performance.timing ||\n          !window.PerformancePaintTiming\n        ) &#123;\n          return\n        &#125;\n\n        const &#123; performance &#125; = window\n\n        // Some stuff is not available on about:blank as it requires a navigation to occur,\n        // let&#x27;s harden the code to not fail then:\n        const ntEntryFallback = &#123;\n          nextHopProtocol: &#x27;h2&#x27;,\n          type: &#x27;other&#x27;\n        &#125;\n\n        // The API exposes some funky info regarding the connection\n        const protocolInfo = &#123;\n          get connectionInfo() &#123;\n            const ntEntry =\n              performance.getEntriesByType(&#x27;navigation&#x27;)[0] || ntEntryFallback\n            return ntEntry.nextHopProtocol\n          &#125;,\n          get npnNegotiatedProtocol() &#123;\n            // NPN is deprecated in favor of ALPN, but this implementation returns the\n            // HTTP/2 or HTTP2+QUIC/39 requests negotiated via ALPN.\n            const ntEntry =\n              performance.getEntriesByType(&#x27;navigation&#x27;)[0] || ntEntryFallback\n            return [&#x27;h2&#x27;, &#x27;hq&#x27;].includes(ntEntry.nextHopProtocol)\n              ? ntEntry.nextHopProtocol\n              : &#x27;unknown&#x27;\n          &#125;,\n          get navigationType() &#123;\n            const ntEntry =\n              performance.getEntriesByType(&#x27;navigation&#x27;)[0] || ntEntryFallback\n            return ntEntry.type\n          &#125;,\n          get wasAlternateProtocolAvailable() &#123;\n            // The Alternate-Protocol header is deprecated in favor of Alt-Svc\n            // (https://www.mnot.net/blog/2016/03/09/alt-svc), so technically this\n            // should always return false.\n            return false\n          &#125;,\n          get wasFetchedViaSpdy() &#123;\n            // SPDY is deprecated in favor of HTTP/2, but this implementation returns\n            // true for HTTP/2 or HTTP2+QUIC/39 as well.\n            const ntEntry =\n              performance.getEntriesByType(&#x27;navigation&#x27;)[0] || ntEntryFallback\n            return [&#x27;h2&#x27;, &#x27;hq&#x27;].includes(ntEntry.nextHopProtocol)\n          &#125;,\n          get wasNpnNegotiated() &#123;\n            // NPN is deprecated in favor of ALPN, but this implementation returns true\n            // for HTTP/2 or HTTP2+QUIC/39 requests negotiated via ALPN.\n            const ntEntry =\n              performance.getEntriesByType(&#x27;navigation&#x27;)[0] || ntEntryFallback\n            return [&#x27;h2&#x27;, &#x27;hq&#x27;].includes(ntEntry.nextHopProtocol)\n          &#125;\n        &#125;\n\n        const &#123; timing &#125; = window.performance\n\n        // Truncate number to specific number of decimals, most of the `loadTimes` stuff has 3\n        function toFixed(num, fixed) &#123;\n          var re = new RegExp(&#x27;^-?\\\\d+(?:.\\\\d&#123;0,&#x27; + (fixed || -1) + &#x27;&#125;)?&#x27;)\n          return num.toString().match(re)[0]\n        &#125;\n\n        const timingInfo = &#123;\n          get firstPaintAfterLoadTime() &#123;\n            // This was never actually implemented and always returns 0.\n            return 0\n          &#125;,\n          get requestTime() &#123;\n            return timing.navigationStart / 1000\n          &#125;,\n          get startLoadTime() &#123;\n            return timing.navigationStart / 1000\n          &#125;,\n          get commitLoadTime() &#123;\n            return timing.responseStart / 1000\n          &#125;,\n          get finishDocumentLoadTime() &#123;\n            return timing.domContentLoadedEventEnd / 1000\n          &#125;,\n          get finishLoadTime() &#123;\n            return timing.loadEventEnd / 1000\n          &#125;,\n          get firstPaintTime() &#123;\n            const fpEntry = performance.getEntriesByType(&#x27;paint&#x27;)[0] || &#123;\n              startTime: timing.loadEventEnd / 1000 // Fallback if no navigation occured (`about:blank`)\n            &#125;\n            return toFixed(\n              (fpEntry.startTime + performance.timeOrigin) / 1000,\n              3\n            )\n          &#125;\n        &#125;\n\n        window.chrome.loadTimes = function() &#123;\n          return &#123;\n            ...protocolInfo,\n            ...timingInfo\n          &#125;\n        &#125;\n        utils.patchToString(window.chrome.loadTimes)\n      &#125;&quot;</span>,<span class="attr">_args</span>:[&#123;<span class="attr">opts</span>:&#123;&#125;&#125;]&#125;),(<span class="function">(<span class="params">&#123;_utilsFns:_utilsFns,_mainFunction:_mainFunction,_args:_args&#125;</span>)=&gt;</span>&#123;<span class="keyword">const</span> utils=<span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(_utilsFns).<span class="title function_">map</span>((<span class="function">(<span class="params">[key,value]</span>)=&gt;</span>[key,<span class="built_in">eval</span>(value)])));utils.<span class="title function_">init</span>(),<span class="built_in">eval</span>(_mainFunction)(utils,..._args)&#125;)(&#123;<span class="attr">_utilsFns</span>:&#123;<span class="attr">init</span>:<span class="string">&quot;() =&gt; &#123;\n  utils.preloadCache()\n&#125;&quot;</span>,<span class="attr">stripProxyFromErrors</span>:<span class="string">&quot;(handler = &#123;&#125;) =&gt; &#123;\n  const newHandler = &#123;\n    setPrototypeOf: function (target, proto) &#123;\n      if (proto === null)\n        throw new TypeError(&#x27;Cannot convert object to primitive value&#x27;)\n      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) &#123;\n        throw new TypeError(&#x27;Cyclic __proto__ value&#x27;)\n      &#125;\n      return Reflect.setPrototypeOf(target, proto)\n    &#125;\n  &#125;\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\n  const traps = Object.getOwnPropertyNames(handler)\n  traps.forEach(trap =&gt; &#123;\n    newHandler[trap] = function () &#123;\n      try &#123;\n        // Forward the call to the defined proxy handler\n        return handler[trap].apply(this, arguments || [])\n      &#125; catch (err) &#123;\n        // Stack traces differ per browser, we only support chromium based ones currently\n        if (!err || !err.stack || !err.stack.includes(`at `)) &#123;\n          throw err\n        &#125;\n\n        // When something throws within one of our traps the Proxy will show up in error stacks\n        // An earlier implementation of this code would simply strip lines with a blacklist,\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\n        // We try to use a known \&quot;anchor\&quot; line for that and strip it with everything above it.\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\n\n        const stripWithBlacklist = (stack, stripFirstLine = true) =&gt; &#123;\n          const blacklist = [\n            `at Reflect.$&#123;trap&#125; `, // e.g. Reflect.get or Reflect.apply\n            `at Object.$&#123;trap&#125; `, // e.g. Object.get or Object.apply\n            `at Object.newHandler.&lt;computed&gt; [as $&#123;trap&#125;] ` // caused by this very wrapper :-)\n          ]\n          return (\n            err.stack\n              .split(&#x27;\\n&#x27;)\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\n              .filter((line, index) =&gt; !(index === 1 &amp;&amp; stripFirstLine))\n              // Check if the line starts with one of our blacklisted strings\n              .filter(line =&gt; !blacklist.some(bl =&gt; line.trim().startsWith(bl)))\n              .join(&#x27;\\n&#x27;)\n          )\n        &#125;\n\n        const stripWithAnchor = (stack, anchor) =&gt; &#123;\n          const stackArr = stack.split(&#x27;\\n&#x27;)\n          anchor = anchor || `at Object.newHandler.&lt;computed&gt; [as $&#123;trap&#125;] ` // Known first Proxy line in chromium\n          const anchorIndex = stackArr.findIndex(line =&gt;\n            line.trim().startsWith(anchor)\n          )\n          if (anchorIndex === -1) &#123;\n            return false // 404, anchor not found\n          &#125;\n          // Strip everything from the top until we reach the anchor line\n          // Note: We&#x27;re keeping the 1st line (zero index) as it&#x27;s unrelated (e.g. `TypeError`)\n          stackArr.splice(1, anchorIndex)\n          return stackArr.join(&#x27;\\n&#x27;)\n        &#125;\n\n        // Special cases due to our nested toString proxies\n        err.stack = err.stack.replace(\n          &#x27;at Object.toString (&#x27;,\n          &#x27;at Function.toString (&#x27;\n        )\n        if ((err.stack || &#x27;&#x27;).includes(&#x27;at Function.toString (&#x27;)) &#123;\n          err.stack = stripWithBlacklist(err.stack, false)\n          throw err\n        &#125;\n\n        // Try using the anchor method, fallback to blacklist if necessary\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\n\n        throw err // Re-throw our now sanitized error\n      &#125;\n    &#125;\n  &#125;)\n  return newHandler\n&#125;&quot;</span>,<span class="attr">stripErrorWithAnchor</span>:<span class="string">&quot;(err, anchor) =&gt; &#123;\n  const stackArr = err.stack.split(&#x27;\\n&#x27;)\n  const anchorIndex = stackArr.findIndex(line =&gt; line.trim().startsWith(anchor))\n  if (anchorIndex === -1) &#123;\n    return err // 404, anchor not found\n  &#125;\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\n  // Note: We&#x27;re keeping the 1st line (zero index) as it&#x27;s unrelated (e.g. `TypeError`)\n  stackArr.splice(1, anchorIndex)\n  err.stack = stackArr.join(&#x27;\\n&#x27;)\n  return err\n&#125;&quot;</span>,<span class="attr">replaceProperty</span>:<span class="string">&quot;(obj, propName, descriptorOverrides = &#123;&#125;) =&gt; &#123;\n  return Object.defineProperty(obj, propName, &#123;\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || &#123;&#125;),\n    // Add our overrides (e.g. value, get())\n    ...descriptorOverrides\n  &#125;)\n&#125;&quot;</span>,<span class="attr">preloadCache</span>:<span class="string">&quot;() =&gt; &#123;\n  if (utils.cache) &#123;\n    return\n  &#125;\n  utils.cache = &#123;\n    // Used in our proxies\n    Reflect: &#123;\n      get: Reflect.get.bind(Reflect),\n      apply: Reflect.apply.bind(Reflect)\n    &#125;,\n    // Used in `makeNativeString`\n    nativeToStringStr: Function.toString + &#x27;&#x27; // =&gt; `function toString() &#123; [native code] &#125;`\n  &#125;\n&#125;&quot;</span>,<span class="attr">makeNativeString</span>:<span class="string">&quot;(name = &#x27;&#x27;) =&gt; &#123;\n  return utils.cache.nativeToStringStr.replace(&#x27;toString&#x27;, name || &#x27;&#x27;)\n&#125;&quot;</span>,<span class="attr">patchToString</span>:<span class="string">&quot;(obj, str = &#x27;&#x27;) =&gt; &#123;\n  const handler = &#123;\n    apply: function (target, ctx) &#123;\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \&quot;\&quot;`\n      if (ctx === Function.prototype.toString) &#123;\n        return utils.makeNativeString(&#x27;toString&#x27;)\n      &#125;\n      // `toString` targeted at our proxied Object detected\n      if (ctx === obj) &#123;\n        // We either return the optional string verbatim or derive the most desired result automatically\n        return str || utils.makeNativeString(obj.name)\n      &#125;\n      // Check if the toString protype of the context is the same as the global prototype,\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\n      const hasSameProto = Object.getPrototypeOf(\n        Function.prototype.toString\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\n      if (!hasSameProto) &#123;\n        // Pass the call on to the local Function.prototype.toString instead\n        return ctx.toString()\n      &#125;\n      return target.call(ctx)\n    &#125;\n  &#125;\n\n  const toStringProxy = new Proxy(\n    Function.prototype.toString,\n    utils.stripProxyFromErrors(handler)\n  )\n  utils.replaceProperty(Function.prototype, &#x27;toString&#x27;, &#123;\n    value: toStringProxy\n  &#125;)\n&#125;&quot;</span>,<span class="attr">patchToStringNested</span>:<span class="string">&quot;(obj = &#123;&#125;) =&gt; &#123;\n  return utils.execRecursively(obj, [&#x27;function&#x27;], utils.patchToString)\n&#125;&quot;</span>,<span class="attr">redirectToString</span>:<span class="string">&quot;(proxyObj, originalObj) =&gt; &#123;\n  const handler = &#123;\n    apply: function (target, ctx) &#123;\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \&quot;\&quot;`\n      if (ctx === Function.prototype.toString) &#123;\n        return utils.makeNativeString(&#x27;toString&#x27;)\n      &#125;\n\n      // `toString` targeted at our proxied Object detected\n      if (ctx === proxyObj) &#123;\n        const fallback = () =&gt;\n          originalObj &amp;&amp; originalObj.name\n            ? utils.makeNativeString(originalObj.name)\n            : utils.makeNativeString(proxyObj.name)\n\n        // Return the toString representation of our original object if possible\n        return originalObj + &#x27;&#x27; || fallback()\n      &#125;\n\n      if (typeof ctx === &#x27;undefined&#x27; || ctx === null) &#123;\n        return target.call(ctx)\n      &#125;\n\n      // Check if the toString protype of the context is the same as the global prototype,\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\n      const hasSameProto = Object.getPrototypeOf(\n        Function.prototype.toString\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\n      if (!hasSameProto) &#123;\n        // Pass the call on to the local Function.prototype.toString instead\n        return ctx.toString()\n      &#125;\n\n      return target.call(ctx)\n    &#125;\n  &#125;\n\n  const toStringProxy = new Proxy(\n    Function.prototype.toString,\n    utils.stripProxyFromErrors(handler)\n  )\n  utils.replaceProperty(Function.prototype, &#x27;toString&#x27;, &#123;\n    value: toStringProxy\n  &#125;)\n&#125;&quot;</span>,<span class="attr">replaceWithProxy</span>:<span class="string">&quot;(obj, propName, handler) =&gt; &#123;\n  const originalObj = obj[propName]\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, &#123; value: proxyObj &#125;)\n  utils.redirectToString(proxyObj, originalObj)\n\n  return true\n&#125;&quot;</span>,<span class="attr">replaceGetterWithProxy</span>:<span class="string">&quot;(obj, propName, handler) =&gt; &#123;\n  const fn = Object.getOwnPropertyDescriptor(obj, propName).get\n  const fnStr = fn.toString() // special getter function string\n  const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, &#123; get: proxyObj &#125;)\n  utils.patchToString(proxyObj, fnStr)\n\n  return true\n&#125;&quot;</span>,<span class="attr">replaceGetterSetter</span>:<span class="string">&quot;(obj, propName, handlerGetterSetter) =&gt; &#123;\n  const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)\n  const handler = &#123; ...ownPropertyDescriptor &#125;\n\n  if (handlerGetterSetter.get !== undefined) &#123;\n    const nativeFn = ownPropertyDescriptor.get\n    handler.get = function() &#123;\n      return handlerGetterSetter.get.call(this, nativeFn.bind(this))\n    &#125;\n    utils.redirectToString(handler.get, nativeFn)\n  &#125;\n\n  if (handlerGetterSetter.set !== undefined) &#123;\n    const nativeFn = ownPropertyDescriptor.set\n    handler.set = function(newValue) &#123;\n      handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this))\n    &#125;\n    utils.redirectToString(handler.set, nativeFn)\n  &#125;\n\n  Object.defineProperty(obj, propName, handler)\n&#125;&quot;</span>,<span class="attr">mockWithProxy</span>:<span class="string">&quot;(obj, propName, pseudoTarget, handler) =&gt; &#123;\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, &#123; value: proxyObj &#125;)\n  utils.patchToString(proxyObj)\n\n  return true\n&#125;&quot;</span>,<span class="attr">createProxy</span>:<span class="string">&quot;(pseudoTarget, handler) =&gt; &#123;\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\n  utils.patchToString(proxyObj)\n\n  return proxyObj\n&#125;&quot;</span>,<span class="attr">splitObjPath</span>:<span class="string">&quot;objPath =&gt; (&#123;\n  // Remove last dot entry (property) ==&gt; `HTMLMediaElement.prototype`\n  objName: objPath.split(&#x27;.&#x27;).slice(0, -1).join(&#x27;.&#x27;),\n  // Extract last dot entry ==&gt; `canPlayType`\n  propName: objPath.split(&#x27;.&#x27;).slice(-1)[0]\n&#125;)&quot;</span>,<span class="attr">replaceObjPathWithProxy</span>:<span class="string">&quot;(objPath, handler) =&gt; &#123;\n  const &#123; objName, propName &#125; = utils.splitObjPath(objPath)\n  const obj = eval(objName) // eslint-disable-line no-eval\n  return utils.replaceWithProxy(obj, propName, handler)\n&#125;&quot;</span>,<span class="attr">execRecursively</span>:<span class="string">&quot;(obj = &#123;&#125;, typeFilter = [], fn) =&gt; &#123;\n  function recurse(obj) &#123;\n    for (const key in obj) &#123;\n      if (obj[key] === undefined) &#123;\n        continue\n      &#125;\n      if (obj[key] &amp;&amp; typeof obj[key] === &#x27;object&#x27;) &#123;\n        recurse(obj[key])\n      &#125; else &#123;\n        if (obj[key] &amp;&amp; typeFilter.includes(typeof obj[key])) &#123;\n          fn.call(this, obj[key])\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n  recurse(obj)\n  return obj\n&#125;&quot;</span>,<span class="attr">stringifyFns</span>:<span class="string">&quot;(fnObj = &#123; hello: () =&gt; &#x27;world&#x27; &#125;) =&gt; &#123;\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\n  // https://github.com/feross/fromentries\n  function fromEntries(iterable) &#123;\n    return [...iterable].reduce((obj, [key, val]) =&gt; &#123;\n      obj[key] = val\n      return obj\n    &#125;, &#123;&#125;)\n  &#125;\n  return (Object.fromEntries || fromEntries)(\n    Object.entries(fnObj)\n      .filter(([key, value]) =&gt; typeof value === &#x27;function&#x27;)\n      .map(([key, value]) =&gt; [key, value.toString()]) // eslint-disable-line no-eval\n  )\n&#125;&quot;</span>,<span class="attr">materializeFns</span>:<span class="string">&quot;(fnStrObj = &#123; hello: \&quot;() =&gt; &#x27;world&#x27;\&quot; &#125;) =&gt; &#123;\n  return Object.fromEntries(\n    Object.entries(fnStrObj).map(([key, value]) =&gt; &#123;\n      if (value.startsWith(&#x27;function&#x27;)) &#123;\n        // some trickery is needed to make oldschool functions work :-)\n        return [key, eval(`() =&gt; $&#123;value&#125;`)()] // eslint-disable-line no-eval\n      &#125; else &#123;\n        // arrow functions just work\n        return [key, eval(value)] // eslint-disable-line no-eval\n      &#125;\n    &#125;)\n  )\n&#125;&quot;</span>,<span class="attr">makeHandler</span>:<span class="string">&quot;() =&gt; (&#123;\n  // Used by simple `navigator` getter evasions\n  getterValue: value =&gt; (&#123;\n    apply(target, ctx, args) &#123;\n      // Let&#x27;s fetch the value first, to trigger and escalate potential errors\n      // Illegal invocations like `navigator.__proto__.vendor` will throw here\n      utils.cache.Reflect.apply(...arguments)\n      return value\n    &#125;\n  &#125;)\n&#125;)&quot;</span>,<span class="attr">arrayEquals</span>:<span class="string">&quot;(array1, array2) =&gt; &#123;\n  if (array1.length !== array2.length) &#123;\n    return false\n  &#125;\n  for (let i = 0; i &lt; array1.length; ++i) &#123;\n    if (array1[i] !== array2[i]) &#123;\n      return false\n    &#125;\n  &#125;\n  return true\n&#125;&quot;</span>,<span class="attr">memoize</span>:<span class="string">&quot;fn =&gt; &#123;\n  const cache = []\n  return function(...args) &#123;\n    if (!cache.some(c =&gt; utils.arrayEquals(c.key, args))) &#123;\n      cache.push(&#123; key: args, value: fn.apply(this, args) &#125;)\n    &#125;\n    return cache.find(c =&gt; utils.arrayEquals(c.key, args)).value\n  &#125;\n&#125;&quot;</span>&#125;,<span class="attr">_mainFunction</span>:<span class="string">&quot;(utils, &#123; opts, STATIC_DATA &#125;) =&gt; &#123;\n        if (!window.chrome) &#123;\n          // Use the exact property descriptor found in headful Chrome\n          // fetch it via `Object.getOwnPropertyDescriptor(window, &#x27;chrome&#x27;)`\n          Object.defineProperty(window, &#x27;chrome&#x27;, &#123;\n            writable: true,\n            enumerable: true,\n            configurable: false, // note!\n            value: &#123;&#125; // We&#x27;ll extend that later\n          &#125;)\n        &#125;\n\n        // That means we&#x27;re running headful and don&#x27;t need to mock anything\n        const existsAlready = &#x27;runtime&#x27; in window.chrome\n        // `chrome.runtime` is only exposed on secure origins\n        const isNotSecure = !window.location.protocol.startsWith(&#x27;https&#x27;)\n        if (existsAlready || (isNotSecure &amp;&amp; !opts.runOnInsecureOrigins)) &#123;\n          return // Nothing to do here\n        &#125;\n\n        window.chrome.runtime = &#123;\n          // There&#x27;s a bunch of static data in that property which doesn&#x27;t seem to change,\n          // we should periodically check for updates: `JSON.stringify(window.chrome.runtime, null, 2)`\n          ...STATIC_DATA,\n          // `chrome.runtime.id` is extension related and returns undefined in Chrome\n          get id() &#123;\n            return undefined\n          &#125;,\n          // These two require more sophisticated mocks\n          connect: null,\n          sendMessage: null\n        &#125;\n\n        const makeCustomRuntimeErrors = (preamble, method, extensionId) =&gt; (&#123;\n          NoMatchingSignature: new TypeError(\n            preamble + `No matching signature.`\n          ),\n          MustSpecifyExtensionID: new TypeError(\n            preamble +\n              `$&#123;method&#125; called from a webpage must specify an Extension ID (string) for its first argument.`\n          ),\n          InvalidExtensionID: new TypeError(\n            preamble + `Invalid extension id: &#x27;$&#123;extensionId&#125;&#x27;`\n          )\n        &#125;)\n\n        // Valid Extension IDs are 32 characters in length and use the letter `a` to `p`:\n        // https://source.chromium.org/chromium/chromium/src/+/master:components/crx_file/id_util.cc;drc=14a055ccb17e8c8d5d437fe080faba4c6f07beac;l=90\n        const isValidExtensionID = str =&gt;\n          str.length === 32 &amp;&amp; str.toLowerCase().match(/^[a-p]+$/)\n\n        /** Mock `chrome.runtime.sendMessage` */\n        const sendMessageHandler = &#123;\n          apply: function(target, ctx, args) &#123;\n            const [extensionId, options, responseCallback] = args || []\n\n            // Define custom errors\n            const errorPreamble = `Error in invocation of runtime.sendMessage(optional string extensionId, any message, optional object options, optional function responseCallback): `\n            const Errors = makeCustomRuntimeErrors(\n              errorPreamble,\n              `chrome.runtime.sendMessage()`,\n              extensionId\n            )\n\n            // Check if the call signature looks ok\n            const noArguments = args.length === 0\n            const tooManyArguments = args.length &gt; 4\n            const incorrectOptions = options &amp;&amp; typeof options !== &#x27;object&#x27;\n            const incorrectResponseCallback =\n              responseCallback &amp;&amp; typeof responseCallback !== &#x27;function&#x27;\n            if (\n              noArguments ||\n              tooManyArguments ||\n              incorrectOptions ||\n              incorrectResponseCallback\n            ) &#123;\n              throw Errors.NoMatchingSignature\n            &#125;\n\n            // At least 2 arguments are required before we even validate the extension ID\n            if (args.length &lt; 2) &#123;\n              throw Errors.MustSpecifyExtensionID\n            &#125;\n\n            // Now let&#x27;s make sure we got a string as extension ID\n            if (typeof extensionId !== &#x27;string&#x27;) &#123;\n              throw Errors.NoMatchingSignature\n            &#125;\n\n            if (!isValidExtensionID(extensionId)) &#123;\n              throw Errors.InvalidExtensionID\n            &#125;\n\n            return undefined // Normal behavior\n          &#125;\n        &#125;\n        utils.mockWithProxy(\n          window.chrome.runtime,\n          &#x27;sendMessage&#x27;,\n          function sendMessage() &#123;&#125;,\n          sendMessageHandler\n        )\n\n        /**\n         * Mock `chrome.runtime.connect`\n         *\n         * @see https://developer.chrome.com/apps/runtime#method-connect\n         */\n        const connectHandler = &#123;\n          apply: function(target, ctx, args) &#123;\n            const [extensionId, connectInfo] = args || []\n\n            // Define custom errors\n            const errorPreamble = `Error in invocation of runtime.connect(optional string extensionId, optional object connectInfo): `\n            const Errors = makeCustomRuntimeErrors(\n              errorPreamble,\n              `chrome.runtime.connect()`,\n              extensionId\n            )\n\n            // Behavior differs a bit from sendMessage:\n            const noArguments = args.length === 0\n            const emptyStringArgument = args.length === 1 &amp;&amp; extensionId === &#x27;&#x27;\n            if (noArguments || emptyStringArgument) &#123;\n              throw Errors.MustSpecifyExtensionID\n            &#125;\n\n            const tooManyArguments = args.length &gt; 2\n            const incorrectConnectInfoType =\n              connectInfo &amp;&amp; typeof connectInfo !== &#x27;object&#x27;\n\n            if (tooManyArguments || incorrectConnectInfoType) &#123;\n              throw Errors.NoMatchingSignature\n            &#125;\n\n            const extensionIdIsString = typeof extensionId === &#x27;string&#x27;\n            if (extensionIdIsString &amp;&amp; extensionId === &#x27;&#x27;) &#123;\n              throw Errors.MustSpecifyExtensionID\n            &#125;\n            if (extensionIdIsString &amp;&amp; !isValidExtensionID(extensionId)) &#123;\n              throw Errors.InvalidExtensionID\n            &#125;\n\n            // There&#x27;s another edge-case here: extensionId is optional so we might find a connectInfo object as first param, which we need to validate\n            const validateConnectInfo = ci =&gt; &#123;\n              // More than a first param connectInfo as been provided\n              if (args.length &gt; 1) &#123;\n                throw Errors.NoMatchingSignature\n              &#125;\n              // An empty connectInfo has been provided\n              if (Object.keys(ci).length === 0) &#123;\n                throw Errors.MustSpecifyExtensionID\n              &#125;\n              // Loop over all connectInfo props an check them\n              Object.entries(ci).forEach(([k, v]) =&gt; &#123;\n                const isExpected = [&#x27;name&#x27;, &#x27;includeTlsChannelId&#x27;].includes(k)\n                if (!isExpected) &#123;\n                  throw new TypeError(\n                    errorPreamble + `Unexpected property: &#x27;$&#123;k&#125;&#x27;.`\n                  )\n                &#125;\n                const MismatchError = (propName, expected, found) =&gt;\n                  TypeError(\n                    errorPreamble +\n                      `Error at property &#x27;$&#123;propName&#125;&#x27;: Invalid type: expected $&#123;expected&#125;, found $&#123;found&#125;.`\n                  )\n                if (k === &#x27;name&#x27; &amp;&amp; typeof v !== &#x27;string&#x27;) &#123;\n                  throw MismatchError(k, &#x27;string&#x27;, typeof v)\n                &#125;\n                if (k === &#x27;includeTlsChannelId&#x27; &amp;&amp; typeof v !== &#x27;boolean&#x27;) &#123;\n                  throw MismatchError(k, &#x27;boolean&#x27;, typeof v)\n                &#125;\n              &#125;)\n            &#125;\n            if (typeof extensionId === &#x27;object&#x27;) &#123;\n              validateConnectInfo(extensionId)\n              throw Errors.MustSpecifyExtensionID\n            &#125;\n\n            // Unfortunately even when the connect fails Chrome will return an object with methods we need to mock as well\n            return utils.patchToStringNested(makeConnectResponse())\n          &#125;\n        &#125;\n        utils.mockWithProxy(\n          window.chrome.runtime,\n          &#x27;connect&#x27;,\n          function connect() &#123;&#125;,\n          connectHandler\n        )\n\n        function makeConnectResponse() &#123;\n          const onSomething = () =&gt; (&#123;\n            addListener: function addListener() &#123;&#125;,\n            dispatch: function dispatch() &#123;&#125;,\n            hasListener: function hasListener() &#123;&#125;,\n            hasListeners: function hasListeners() &#123;\n              return false\n            &#125;,\n            removeListener: function removeListener() &#123;&#125;\n          &#125;)\n\n          const response = &#123;\n            name: &#x27;&#x27;,\n            sender: undefined,\n            disconnect: function disconnect() &#123;&#125;,\n            onDisconnect: onSomething(),\n            onMessage: onSomething(),\n            postMessage: function postMessage() &#123;\n              if (!arguments.length) &#123;\n                throw new TypeError(`Insufficient number of arguments.`)\n              &#125;\n              throw new Error(`Attempting to use a disconnected port object`)\n            &#125;\n          &#125;\n          return response\n        &#125;\n      &#125;&quot;</span>,<span class="attr">_args</span>:[&#123;<span class="attr">opts</span>:&#123;<span class="attr">runOnInsecureOrigins</span>:!<span class="number">1</span>&#125;,<span class="attr">STATIC_DATA</span>:&#123;<span class="title class_">OnInstalledReason</span>:&#123;<span class="attr">CHROME_UPDATE</span>:<span class="string">&quot;chrome_update&quot;</span>,<span class="attr">INSTALL</span>:<span class="string">&quot;install&quot;</span>,<span class="attr">SHARED_MODULE_UPDATE</span>:<span class="string">&quot;shared_module_update&quot;</span>,<span class="attr">UPDATE</span>:<span class="string">&quot;update&quot;</span>&#125;,<span class="title class_">OnRestartRequiredReason</span>:&#123;<span class="attr">APP_UPDATE</span>:<span class="string">&quot;app_update&quot;</span>,<span class="attr">OS_UPDATE</span>:<span class="string">&quot;os_update&quot;</span>,<span class="attr">PERIODIC</span>:<span class="string">&quot;periodic&quot;</span>&#125;,<span class="title class_">PlatformArch</span>:&#123;<span class="attr">ARM</span>:<span class="string">&quot;arm&quot;</span>,<span class="title class_">ARM64</span>:<span class="string">&quot;arm64&quot;</span>,<span class="attr">MIPS</span>:<span class="string">&quot;mips&quot;</span>,<span class="title class_">MIPS64</span>:<span class="string">&quot;mips64&quot;</span>,<span class="attr">X86_32</span>:<span class="string">&quot;x86-32&quot;</span>,<span class="attr">X86_64</span>:<span class="string">&quot;x86-64&quot;</span>&#125;,<span class="title class_">PlatformNaclArch</span>:&#123;<span class="attr">ARM</span>:<span class="string">&quot;arm&quot;</span>,<span class="attr">MIPS</span>:<span class="string">&quot;mips&quot;</span>,<span class="title class_">MIPS64</span>:<span class="string">&quot;mips64&quot;</span>,<span class="attr">X86_32</span>:<span class="string">&quot;x86-32&quot;</span>,<span class="attr">X86_64</span>:<span class="string">&quot;x86-64&quot;</span>&#125;,<span class="title class_">PlatformOs</span>:&#123;<span class="attr">ANDROID</span>:<span class="string">&quot;android&quot;</span>,<span class="attr">CROS</span>:<span class="string">&quot;cros&quot;</span>,<span class="attr">LINUX</span>:<span class="string">&quot;linux&quot;</span>,<span class="attr">MAC</span>:<span class="string">&quot;mac&quot;</span>,<span class="attr">OPENBSD</span>:<span class="string">&quot;openbsd&quot;</span>,<span class="attr">WIN</span>:<span class="string">&quot;win&quot;</span>&#125;,<span class="title class_">RequestUpdateCheckStatus</span>:&#123;<span class="attr">NO_UPDATE</span>:<span class="string">&quot;no_update&quot;</span>,<span class="attr">THROTTLED</span>:<span class="string">&quot;throttled&quot;</span>,<span class="attr">UPDATE_AVAILABLE</span>:<span class="string">&quot;update_available&quot;</span>&#125;&#125;&#125;]&#125;),(<span class="function">(<span class="params">&#123;_utilsFns:_utilsFns,_mainFunction:_mainFunction,_args:_args&#125;</span>)=&gt;</span>&#123;<span class="keyword">const</span> utils=<span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(_utilsFns).<span class="title function_">map</span>((<span class="function">(<span class="params">[key,value]</span>)=&gt;</span>[key,<span class="built_in">eval</span>(value)])));utils.<span class="title function_">init</span>(),<span class="built_in">eval</span>(_mainFunction)(utils,..._args)&#125;)(&#123;<span class="attr">_utilsFns</span>:&#123;<span class="attr">init</span>:<span class="string">&quot;() =&gt; &#123;\n  utils.preloadCache()\n&#125;&quot;</span>,<span class="attr">stripProxyFromErrors</span>:<span class="string">&quot;(handler = &#123;&#125;) =&gt; &#123;\n  const newHandler = &#123;\n    setPrototypeOf: function (target, proto) &#123;\n      if (proto === null)\n        throw new TypeError(&#x27;Cannot convert object to primitive value&#x27;)\n      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) &#123;\n        throw new TypeError(&#x27;Cyclic __proto__ value&#x27;)\n      &#125;\n      return Reflect.setPrototypeOf(target, proto)\n    &#125;\n  &#125;\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\n  const traps = Object.getOwnPropertyNames(handler)\n  traps.forEach(trap =&gt; &#123;\n    newHandler[trap] = function () &#123;\n      try &#123;\n        // Forward the call to the defined proxy handler\n        return handler[trap].apply(this, arguments || [])\n      &#125; catch (err) &#123;\n        // Stack traces differ per browser, we only support chromium based ones currently\n        if (!err || !err.stack || !err.stack.includes(`at `)) &#123;\n          throw err\n        &#125;\n\n        // When something throws within one of our traps the Proxy will show up in error stacks\n        // An earlier implementation of this code would simply strip lines with a blacklist,\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\n        // We try to use a known \&quot;anchor\&quot; line for that and strip it with everything above it.\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\n\n        const stripWithBlacklist = (stack, stripFirstLine = true) =&gt; &#123;\n          const blacklist = [\n            `at Reflect.$&#123;trap&#125; `, // e.g. Reflect.get or Reflect.apply\n            `at Object.$&#123;trap&#125; `, // e.g. Object.get or Object.apply\n            `at Object.newHandler.&lt;computed&gt; [as $&#123;trap&#125;] ` // caused by this very wrapper :-)\n          ]\n          return (\n            err.stack\n              .split(&#x27;\\n&#x27;)\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\n              .filter((line, index) =&gt; !(index === 1 &amp;&amp; stripFirstLine))\n              // Check if the line starts with one of our blacklisted strings\n              .filter(line =&gt; !blacklist.some(bl =&gt; line.trim().startsWith(bl)))\n              .join(&#x27;\\n&#x27;)\n          )\n        &#125;\n\n        const stripWithAnchor = (stack, anchor) =&gt; &#123;\n          const stackArr = stack.split(&#x27;\\n&#x27;)\n          anchor = anchor || `at Object.newHandler.&lt;computed&gt; [as $&#123;trap&#125;] ` // Known first Proxy line in chromium\n          const anchorIndex = stackArr.findIndex(line =&gt;\n            line.trim().startsWith(anchor)\n          )\n          if (anchorIndex === -1) &#123;\n            return false // 404, anchor not found\n          &#125;\n          // Strip everything from the top until we reach the anchor line\n          // Note: We&#x27;re keeping the 1st line (zero index) as it&#x27;s unrelated (e.g. `TypeError`)\n          stackArr.splice(1, anchorIndex)\n          return stackArr.join(&#x27;\\n&#x27;)\n        &#125;\n\n        // Special cases due to our nested toString proxies\n        err.stack = err.stack.replace(\n          &#x27;at Object.toString (&#x27;,\n          &#x27;at Function.toString (&#x27;\n        )\n        if ((err.stack || &#x27;&#x27;).includes(&#x27;at Function.toString (&#x27;)) &#123;\n          err.stack = stripWithBlacklist(err.stack, false)\n          throw err\n        &#125;\n\n        // Try using the anchor method, fallback to blacklist if necessary\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\n\n        throw err // Re-throw our now sanitized error\n      &#125;\n    &#125;\n  &#125;)\n  return newHandler\n&#125;&quot;</span>,<span class="attr">stripErrorWithAnchor</span>:<span class="string">&quot;(err, anchor) =&gt; &#123;\n  const stackArr = err.stack.split(&#x27;\\n&#x27;)\n  const anchorIndex = stackArr.findIndex(line =&gt; line.trim().startsWith(anchor))\n  if (anchorIndex === -1) &#123;\n    return err // 404, anchor not found\n  &#125;\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\n  // Note: We&#x27;re keeping the 1st line (zero index) as it&#x27;s unrelated (e.g. `TypeError`)\n  stackArr.splice(1, anchorIndex)\n  err.stack = stackArr.join(&#x27;\\n&#x27;)\n  return err\n&#125;&quot;</span>,<span class="attr">replaceProperty</span>:<span class="string">&quot;(obj, propName, descriptorOverrides = &#123;&#125;) =&gt; &#123;\n  return Object.defineProperty(obj, propName, &#123;\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || &#123;&#125;),\n    // Add our overrides (e.g. value, get())\n    ...descriptorOverrides\n  &#125;)\n&#125;&quot;</span>,<span class="attr">preloadCache</span>:<span class="string">&quot;() =&gt; &#123;\n  if (utils.cache) &#123;\n    return\n  &#125;\n  utils.cache = &#123;\n    // Used in our proxies\n    Reflect: &#123;\n      get: Reflect.get.bind(Reflect),\n      apply: Reflect.apply.bind(Reflect)\n    &#125;,\n    // Used in `makeNativeString`\n    nativeToStringStr: Function.toString + &#x27;&#x27; // =&gt; `function toString() &#123; [native code] &#125;`\n  &#125;\n&#125;&quot;</span>,<span class="attr">makeNativeString</span>:<span class="string">&quot;(name = &#x27;&#x27;) =&gt; &#123;\n  return utils.cache.nativeToStringStr.replace(&#x27;toString&#x27;, name || &#x27;&#x27;)\n&#125;&quot;</span>,<span class="attr">patchToString</span>:<span class="string">&quot;(obj, str = &#x27;&#x27;) =&gt; &#123;\n  const handler = &#123;\n    apply: function (target, ctx) &#123;\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \&quot;\&quot;`\n      if (ctx === Function.prototype.toString) &#123;\n        return utils.makeNativeString(&#x27;toString&#x27;)\n      &#125;\n      // `toString` targeted at our proxied Object detected\n      if (ctx === obj) &#123;\n        // We either return the optional string verbatim or derive the most desired result automatically\n        return str || utils.makeNativeString(obj.name)\n      &#125;\n      // Check if the toString protype of the context is the same as the global prototype,\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\n      const hasSameProto = Object.getPrototypeOf(\n        Function.prototype.toString\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\n      if (!hasSameProto) &#123;\n        // Pass the call on to the local Function.prototype.toString instead\n        return ctx.toString()\n      &#125;\n      return target.call(ctx)\n    &#125;\n  &#125;\n\n  const toStringProxy = new Proxy(\n    Function.prototype.toString,\n    utils.stripProxyFromErrors(handler)\n  )\n  utils.replaceProperty(Function.prototype, &#x27;toString&#x27;, &#123;\n    value: toStringProxy\n  &#125;)\n&#125;&quot;</span>,<span class="attr">patchToStringNested</span>:<span class="string">&quot;(obj = &#123;&#125;) =&gt; &#123;\n  return utils.execRecursively(obj, [&#x27;function&#x27;], utils.patchToString)\n&#125;&quot;</span>,<span class="attr">redirectToString</span>:<span class="string">&quot;(proxyObj, originalObj) =&gt; &#123;\n  const handler = &#123;\n    apply: function (target, ctx) &#123;\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \&quot;\&quot;`\n      if (ctx === Function.prototype.toString) &#123;\n        return utils.makeNativeString(&#x27;toString&#x27;)\n      &#125;\n\n      // `toString` targeted at our proxied Object detected\n      if (ctx === proxyObj) &#123;\n        const fallback = () =&gt;\n          originalObj &amp;&amp; originalObj.name\n            ? utils.makeNativeString(originalObj.name)\n            : utils.makeNativeString(proxyObj.name)\n\n        // Return the toString representation of our original object if possible\n        return originalObj + &#x27;&#x27; || fallback()\n      &#125;\n\n      if (typeof ctx === &#x27;undefined&#x27; || ctx === null) &#123;\n        return target.call(ctx)\n      &#125;\n\n      // Check if the toString protype of the context is the same as the global prototype,\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\n      const hasSameProto = Object.getPrototypeOf(\n        Function.prototype.toString\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\n      if (!hasSameProto) &#123;\n        // Pass the call on to the local Function.prototype.toString instead\n        return ctx.toString()\n      &#125;\n\n      return target.call(ctx)\n    &#125;\n  &#125;\n\n  const toStringProxy = new Proxy(\n    Function.prototype.toString,\n    utils.stripProxyFromErrors(handler)\n  )\n  utils.replaceProperty(Function.prototype, &#x27;toString&#x27;, &#123;\n    value: toStringProxy\n  &#125;)\n&#125;&quot;</span>,<span class="attr">replaceWithProxy</span>:<span class="string">&quot;(obj, propName, handler) =&gt; &#123;\n  const originalObj = obj[propName]\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, &#123; value: proxyObj &#125;)\n  utils.redirectToString(proxyObj, originalObj)\n\n  return true\n&#125;&quot;</span>,<span class="attr">replaceGetterWithProxy</span>:<span class="string">&quot;(obj, propName, handler) =&gt; &#123;\n  const fn = Object.getOwnPropertyDescriptor(obj, propName).get\n  const fnStr = fn.toString() // special getter function string\n  const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, &#123; get: proxyObj &#125;)\n  utils.patchToString(proxyObj, fnStr)\n\n  return true\n&#125;&quot;</span>,<span class="attr">replaceGetterSetter</span>:<span class="string">&quot;(obj, propName, handlerGetterSetter) =&gt; &#123;\n  const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)\n  const handler = &#123; ...ownPropertyDescriptor &#125;\n\n  if (handlerGetterSetter.get !== undefined) &#123;\n    const nativeFn = ownPropertyDescriptor.get\n    handler.get = function() &#123;\n      return handlerGetterSetter.get.call(this, nativeFn.bind(this))\n    &#125;\n    utils.redirectToString(handler.get, nativeFn)\n  &#125;\n\n  if (handlerGetterSetter.set !== undefined) &#123;\n    const nativeFn = ownPropertyDescriptor.set\n    handler.set = function(newValue) &#123;\n      handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this))\n    &#125;\n    utils.redirectToString(handler.set, nativeFn)\n  &#125;\n\n  Object.defineProperty(obj, propName, handler)\n&#125;&quot;</span>,<span class="attr">mockWithProxy</span>:<span class="string">&quot;(obj, propName, pseudoTarget, handler) =&gt; &#123;\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, &#123; value: proxyObj &#125;)\n  utils.patchToString(proxyObj)\n\n  return true\n&#125;&quot;</span>,<span class="attr">createProxy</span>:<span class="string">&quot;(pseudoTarget, handler) =&gt; &#123;\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\n  utils.patchToString(proxyObj)\n\n  return proxyObj\n&#125;&quot;</span>,<span class="attr">splitObjPath</span>:<span class="string">&quot;objPath =&gt; (&#123;\n  // Remove last dot entry (property) ==&gt; `HTMLMediaElement.prototype`\n  objName: objPath.split(&#x27;.&#x27;).slice(0, -1).join(&#x27;.&#x27;),\n  // Extract last dot entry ==&gt; `canPlayType`\n  propName: objPath.split(&#x27;.&#x27;).slice(-1)[0]\n&#125;)&quot;</span>,<span class="attr">replaceObjPathWithProxy</span>:<span class="string">&quot;(objPath, handler) =&gt; &#123;\n  const &#123; objName, propName &#125; = utils.splitObjPath(objPath)\n  const obj = eval(objName) // eslint-disable-line no-eval\n  return utils.replaceWithProxy(obj, propName, handler)\n&#125;&quot;</span>,<span class="attr">execRecursively</span>:<span class="string">&quot;(obj = &#123;&#125;, typeFilter = [], fn) =&gt; &#123;\n  function recurse(obj) &#123;\n    for (const key in obj) &#123;\n      if (obj[key] === undefined) &#123;\n        continue\n      &#125;\n      if (obj[key] &amp;&amp; typeof obj[key] === &#x27;object&#x27;) &#123;\n        recurse(obj[key])\n      &#125; else &#123;\n        if (obj[key] &amp;&amp; typeFilter.includes(typeof obj[key])) &#123;\n          fn.call(this, obj[key])\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n  recurse(obj)\n  return obj\n&#125;&quot;</span>,<span class="attr">stringifyFns</span>:<span class="string">&quot;(fnObj = &#123; hello: () =&gt; &#x27;world&#x27; &#125;) =&gt; &#123;\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\n  // https://github.com/feross/fromentries\n  function fromEntries(iterable) &#123;\n    return [...iterable].reduce((obj, [key, val]) =&gt; &#123;\n      obj[key] = val\n      return obj\n    &#125;, &#123;&#125;)\n  &#125;\n  return (Object.fromEntries || fromEntries)(\n    Object.entries(fnObj)\n      .filter(([key, value]) =&gt; typeof value === &#x27;function&#x27;)\n      .map(([key, value]) =&gt; [key, value.toString()]) // eslint-disable-line no-eval\n  )\n&#125;&quot;</span>,<span class="attr">materializeFns</span>:<span class="string">&quot;(fnStrObj = &#123; hello: \&quot;() =&gt; &#x27;world&#x27;\&quot; &#125;) =&gt; &#123;\n  return Object.fromEntries(\n    Object.entries(fnStrObj).map(([key, value]) =&gt; &#123;\n      if (value.startsWith(&#x27;function&#x27;)) &#123;\n        // some trickery is needed to make oldschool functions work :-)\n        return [key, eval(`() =&gt; $&#123;value&#125;`)()] // eslint-disable-line no-eval\n      &#125; else &#123;\n        // arrow functions just work\n        return [key, eval(value)] // eslint-disable-line no-eval\n      &#125;\n    &#125;)\n  )\n&#125;&quot;</span>,<span class="attr">makeHandler</span>:<span class="string">&quot;() =&gt; (&#123;\n  // Used by simple `navigator` getter evasions\n  getterValue: value =&gt; (&#123;\n    apply(target, ctx, args) &#123;\n      // Let&#x27;s fetch the value first, to trigger and escalate potential errors\n      // Illegal invocations like `navigator.__proto__.vendor` will throw here\n      utils.cache.Reflect.apply(...arguments)\n      return value\n    &#125;\n  &#125;)\n&#125;)&quot;</span>,<span class="attr">arrayEquals</span>:<span class="string">&quot;(array1, array2) =&gt; &#123;\n  if (array1.length !== array2.length) &#123;\n    return false\n  &#125;\n  for (let i = 0; i &lt; array1.length; ++i) &#123;\n    if (array1[i] !== array2[i]) &#123;\n      return false\n    &#125;\n  &#125;\n  return true\n&#125;&quot;</span>,<span class="attr">memoize</span>:<span class="string">&quot;fn =&gt; &#123;\n  const cache = []\n  return function(...args) &#123;\n    if (!cache.some(c =&gt; utils.arrayEquals(c.key, args))) &#123;\n      cache.push(&#123; key: args, value: fn.apply(this, args) &#125;)\n    &#125;\n    return cache.find(c =&gt; utils.arrayEquals(c.key, args)).value\n  &#125;\n&#125;&quot;</span>&#125;,<span class="attr">_mainFunction</span>:<span class="string">&quot;utils =&gt; &#123;\n      /**\n       * Input might look funky, we need to normalize it so e.g. whitespace isn&#x27;t an issue for our spoofing.\n       *\n       * @example\n       * video/webm; codecs=\&quot;vp8, vorbis\&quot;\n       * video/mp4; codecs=\&quot;avc1.42E01E\&quot;\n       * audio/x-m4a;\n       * audio/ogg; codecs=\&quot;vorbis\&quot;\n       * @param &#123;String&#125; arg\n       */\n      const parseInput = arg =&gt; &#123;\n        const [mime, codecStr] = arg.trim().split(&#x27;;&#x27;)\n        let codecs = []\n        if (codecStr &amp;&amp; codecStr.includes(&#x27;codecs=\&quot;&#x27;)) &#123;\n          codecs = codecStr\n            .trim()\n            .replace(`codecs=\&quot;`, &#x27;&#x27;)\n            .replace(`\&quot;`, &#x27;&#x27;)\n            .trim()\n            .split(&#x27;,&#x27;)\n            .filter(x =&gt; !!x)\n            .map(x =&gt; x.trim())\n        &#125;\n        return &#123;\n          mime,\n          codecStr,\n          codecs\n        &#125;\n      &#125;\n\n      const canPlayType = &#123;\n        // Intercept certain requests\n        apply: function(target, ctx, args) &#123;\n          if (!args || !args.length) &#123;\n            return target.apply(ctx, args)\n          &#125;\n          const &#123; mime, codecs &#125; = parseInput(args[0])\n          // This specific mp4 codec is missing in Chromium\n          if (mime === &#x27;video/mp4&#x27;) &#123;\n            if (codecs.includes(&#x27;avc1.42E01E&#x27;)) &#123;\n              return &#x27;probably&#x27;\n            &#125;\n          &#125;\n          // This mimetype is only supported if no codecs are specified\n          if (mime === &#x27;audio/x-m4a&#x27; &amp;&amp; !codecs.length) &#123;\n            return &#x27;maybe&#x27;\n          &#125;\n\n          // This mimetype is only supported if no codecs are specified\n          if (mime === &#x27;audio/aac&#x27; &amp;&amp; !codecs.length) &#123;\n            return &#x27;probably&#x27;\n          &#125;\n          // Everything else as usual\n          return target.apply(ctx, args)\n        &#125;\n      &#125;\n\n      /* global HTMLMediaElement */\n      utils.replaceWithProxy(\n        HTMLMediaElement.prototype,\n        &#x27;canPlayType&#x27;,\n        canPlayType\n      )\n    &#125;&quot;</span>,<span class="attr">_args</span>:[]&#125;),(<span class="function">(<span class="params">&#123;_utilsFns:_utilsFns,_mainFunction:_mainFunction,_args:_args&#125;</span>)=&gt;</span>&#123;<span class="keyword">const</span> utils=<span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(_utilsFns).<span class="title function_">map</span>((<span class="function">(<span class="params">[key,value]</span>)=&gt;</span>[key,<span class="built_in">eval</span>(value)])));utils.<span class="title function_">init</span>(),<span class="built_in">eval</span>(_mainFunction)(utils,..._args)&#125;)(&#123;<span class="attr">_utilsFns</span>:&#123;<span class="attr">init</span>:<span class="string">&quot;() =&gt; &#123;\n  utils.preloadCache()\n&#125;&quot;</span>,<span class="attr">stripProxyFromErrors</span>:<span class="string">&quot;(handler = &#123;&#125;) =&gt; &#123;\n  const newHandler = &#123;\n    setPrototypeOf: function (target, proto) &#123;\n      if (proto === null)\n        throw new TypeError(&#x27;Cannot convert object to primitive value&#x27;)\n      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) &#123;\n        throw new TypeError(&#x27;Cyclic __proto__ value&#x27;)\n      &#125;\n      return Reflect.setPrototypeOf(target, proto)\n    &#125;\n  &#125;\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\n  const traps = Object.getOwnPropertyNames(handler)\n  traps.forEach(trap =&gt; &#123;\n    newHandler[trap] = function () &#123;\n      try &#123;\n        // Forward the call to the defined proxy handler\n        return handler[trap].apply(this, arguments || [])\n      &#125; catch (err) &#123;\n        // Stack traces differ per browser, we only support chromium based ones currently\n        if (!err || !err.stack || !err.stack.includes(`at `)) &#123;\n          throw err\n        &#125;\n\n        // When something throws within one of our traps the Proxy will show up in error stacks\n        // An earlier implementation of this code would simply strip lines with a blacklist,\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\n        // We try to use a known \&quot;anchor\&quot; line for that and strip it with everything above it.\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\n\n        const stripWithBlacklist = (stack, stripFirstLine = true) =&gt; &#123;\n          const blacklist = [\n            `at Reflect.$&#123;trap&#125; `, // e.g. Reflect.get or Reflect.apply\n            `at Object.$&#123;trap&#125; `, // e.g. Object.get or Object.apply\n            `at Object.newHandler.&lt;computed&gt; [as $&#123;trap&#125;] ` // caused by this very wrapper :-)\n          ]\n          return (\n            err.stack\n              .split(&#x27;\\n&#x27;)\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\n              .filter((line, index) =&gt; !(index === 1 &amp;&amp; stripFirstLine))\n              // Check if the line starts with one of our blacklisted strings\n              .filter(line =&gt; !blacklist.some(bl =&gt; line.trim().startsWith(bl)))\n              .join(&#x27;\\n&#x27;)\n          )\n        &#125;\n\n        const stripWithAnchor = (stack, anchor) =&gt; &#123;\n          const stackArr = stack.split(&#x27;\\n&#x27;)\n          anchor = anchor || `at Object.newHandler.&lt;computed&gt; [as $&#123;trap&#125;] ` // Known first Proxy line in chromium\n          const anchorIndex = stackArr.findIndex(line =&gt;\n            line.trim().startsWith(anchor)\n          )\n          if (anchorIndex === -1) &#123;\n            return false // 404, anchor not found\n          &#125;\n          // Strip everything from the top until we reach the anchor line\n          // Note: We&#x27;re keeping the 1st line (zero index) as it&#x27;s unrelated (e.g. `TypeError`)\n          stackArr.splice(1, anchorIndex)\n          return stackArr.join(&#x27;\\n&#x27;)\n        &#125;\n\n        // Special cases due to our nested toString proxies\n        err.stack = err.stack.replace(\n          &#x27;at Object.toString (&#x27;,\n          &#x27;at Function.toString (&#x27;\n        )\n        if ((err.stack || &#x27;&#x27;).includes(&#x27;at Function.toString (&#x27;)) &#123;\n          err.stack = stripWithBlacklist(err.stack, false)\n          throw err\n        &#125;\n\n        // Try using the anchor method, fallback to blacklist if necessary\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\n\n        throw err // Re-throw our now sanitized error\n      &#125;\n    &#125;\n  &#125;)\n  return newHandler\n&#125;&quot;</span>,<span class="attr">stripErrorWithAnchor</span>:<span class="string">&quot;(err, anchor) =&gt; &#123;\n  const stackArr = err.stack.split(&#x27;\\n&#x27;)\n  const anchorIndex = stackArr.findIndex(line =&gt; line.trim().startsWith(anchor))\n  if (anchorIndex === -1) &#123;\n    return err // 404, anchor not found\n  &#125;\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\n  // Note: We&#x27;re keeping the 1st line (zero index) as it&#x27;s unrelated (e.g. `TypeError`)\n  stackArr.splice(1, anchorIndex)\n  err.stack = stackArr.join(&#x27;\\n&#x27;)\n  return err\n&#125;&quot;</span>,<span class="attr">replaceProperty</span>:<span class="string">&quot;(obj, propName, descriptorOverrides = &#123;&#125;) =&gt; &#123;\n  return Object.defineProperty(obj, propName, &#123;\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || &#123;&#125;),\n    // Add our overrides (e.g. value, get())\n    ...descriptorOverrides\n  &#125;)\n&#125;&quot;</span>,<span class="attr">preloadCache</span>:<span class="string">&quot;() =&gt; &#123;\n  if (utils.cache) &#123;\n    return\n  &#125;\n  utils.cache = &#123;\n    // Used in our proxies\n    Reflect: &#123;\n      get: Reflect.get.bind(Reflect),\n      apply: Reflect.apply.bind(Reflect)\n    &#125;,\n    // Used in `makeNativeString`\n    nativeToStringStr: Function.toString + &#x27;&#x27; // =&gt; `function toString() &#123; [native code] &#125;`\n  &#125;\n&#125;&quot;</span>,<span class="attr">makeNativeString</span>:<span class="string">&quot;(name = &#x27;&#x27;) =&gt; &#123;\n  return utils.cache.nativeToStringStr.replace(&#x27;toString&#x27;, name || &#x27;&#x27;)\n&#125;&quot;</span>,<span class="attr">patchToString</span>:<span class="string">&quot;(obj, str = &#x27;&#x27;) =&gt; &#123;\n  const handler = &#123;\n    apply: function (target, ctx) &#123;\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \&quot;\&quot;`\n      if (ctx === Function.prototype.toString) &#123;\n        return utils.makeNativeString(&#x27;toString&#x27;)\n      &#125;\n      // `toString` targeted at our proxied Object detected\n      if (ctx === obj) &#123;\n        // We either return the optional string verbatim or derive the most desired result automatically\n        return str || utils.makeNativeString(obj.name)\n      &#125;\n      // Check if the toString protype of the context is the same as the global prototype,\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\n      const hasSameProto = Object.getPrototypeOf(\n        Function.prototype.toString\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\n      if (!hasSameProto) &#123;\n        // Pass the call on to the local Function.prototype.toString instead\n        return ctx.toString()\n      &#125;\n      return target.call(ctx)\n    &#125;\n  &#125;\n\n  const toStringProxy = new Proxy(\n    Function.prototype.toString,\n    utils.stripProxyFromErrors(handler)\n  )\n  utils.replaceProperty(Function.prototype, &#x27;toString&#x27;, &#123;\n    value: toStringProxy\n  &#125;)\n&#125;&quot;</span>,<span class="attr">patchToStringNested</span>:<span class="string">&quot;(obj = &#123;&#125;) =&gt; &#123;\n  return utils.execRecursively(obj, [&#x27;function&#x27;], utils.patchToString)\n&#125;&quot;</span>,<span class="attr">redirectToString</span>:<span class="string">&quot;(proxyObj, originalObj) =&gt; &#123;\n  const handler = &#123;\n    apply: function (target, ctx) &#123;\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \&quot;\&quot;`\n      if (ctx === Function.prototype.toString) &#123;\n        return utils.makeNativeString(&#x27;toString&#x27;)\n      &#125;\n\n      // `toString` targeted at our proxied Object detected\n      if (ctx === proxyObj) &#123;\n        const fallback = () =&gt;\n          originalObj &amp;&amp; originalObj.name\n            ? utils.makeNativeString(originalObj.name)\n            : utils.makeNativeString(proxyObj.name)\n\n        // Return the toString representation of our original object if possible\n        return originalObj + &#x27;&#x27; || fallback()\n      &#125;\n\n      if (typeof ctx === &#x27;undefined&#x27; || ctx === null) &#123;\n        return target.call(ctx)\n      &#125;\n\n      // Check if the toString protype of the context is the same as the global prototype,\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\n      const hasSameProto = Object.getPrototypeOf(\n        Function.prototype.toString\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\n      if (!hasSameProto) &#123;\n        // Pass the call on to the local Function.prototype.toString instead\n        return ctx.toString()\n      &#125;\n\n      return target.call(ctx)\n    &#125;\n  &#125;\n\n  const toStringProxy = new Proxy(\n    Function.prototype.toString,\n    utils.stripProxyFromErrors(handler)\n  )\n  utils.replaceProperty(Function.prototype, &#x27;toString&#x27;, &#123;\n    value: toStringProxy\n  &#125;)\n&#125;&quot;</span>,<span class="attr">replaceWithProxy</span>:<span class="string">&quot;(obj, propName, handler) =&gt; &#123;\n  const originalObj = obj[propName]\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, &#123; value: proxyObj &#125;)\n  utils.redirectToString(proxyObj, originalObj)\n\n  return true\n&#125;&quot;</span>,<span class="attr">replaceGetterWithProxy</span>:<span class="string">&quot;(obj, propName, handler) =&gt; &#123;\n  const fn = Object.getOwnPropertyDescriptor(obj, propName).get\n  const fnStr = fn.toString() // special getter function string\n  const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, &#123; get: proxyObj &#125;)\n  utils.patchToString(proxyObj, fnStr)\n\n  return true\n&#125;&quot;</span>,<span class="attr">replaceGetterSetter</span>:<span class="string">&quot;(obj, propName, handlerGetterSetter) =&gt; &#123;\n  const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)\n  const handler = &#123; ...ownPropertyDescriptor &#125;\n\n  if (handlerGetterSetter.get !== undefined) &#123;\n    const nativeFn = ownPropertyDescriptor.get\n    handler.get = function() &#123;\n      return handlerGetterSetter.get.call(this, nativeFn.bind(this))\n    &#125;\n    utils.redirectToString(handler.get, nativeFn)\n  &#125;\n\n  if (handlerGetterSetter.set !== undefined) &#123;\n    const nativeFn = ownPropertyDescriptor.set\n    handler.set = function(newValue) &#123;\n      handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this))\n    &#125;\n    utils.redirectToString(handler.set, nativeFn)\n  &#125;\n\n  Object.defineProperty(obj, propName, handler)\n&#125;&quot;</span>,<span class="attr">mockWithProxy</span>:<span class="string">&quot;(obj, propName, pseudoTarget, handler) =&gt; &#123;\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, &#123; value: proxyObj &#125;)\n  utils.patchToString(proxyObj)\n\n  return true\n&#125;&quot;</span>,<span class="attr">createProxy</span>:<span class="string">&quot;(pseudoTarget, handler) =&gt; &#123;\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\n  utils.patchToString(proxyObj)\n\n  return proxyObj\n&#125;&quot;</span>,<span class="attr">splitObjPath</span>:<span class="string">&quot;objPath =&gt; (&#123;\n  // Remove last dot entry (property) ==&gt; `HTMLMediaElement.prototype`\n  objName: objPath.split(&#x27;.&#x27;).slice(0, -1).join(&#x27;.&#x27;),\n  // Extract last dot entry ==&gt; `canPlayType`\n  propName: objPath.split(&#x27;.&#x27;).slice(-1)[0]\n&#125;)&quot;</span>,<span class="attr">replaceObjPathWithProxy</span>:<span class="string">&quot;(objPath, handler) =&gt; &#123;\n  const &#123; objName, propName &#125; = utils.splitObjPath(objPath)\n  const obj = eval(objName) // eslint-disable-line no-eval\n  return utils.replaceWithProxy(obj, propName, handler)\n&#125;&quot;</span>,<span class="attr">execRecursively</span>:<span class="string">&quot;(obj = &#123;&#125;, typeFilter = [], fn) =&gt; &#123;\n  function recurse(obj) &#123;\n    for (const key in obj) &#123;\n      if (obj[key] === undefined) &#123;\n        continue\n      &#125;\n      if (obj[key] &amp;&amp; typeof obj[key] === &#x27;object&#x27;) &#123;\n        recurse(obj[key])\n      &#125; else &#123;\n        if (obj[key] &amp;&amp; typeFilter.includes(typeof obj[key])) &#123;\n          fn.call(this, obj[key])\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n  recurse(obj)\n  return obj\n&#125;&quot;</span>,<span class="attr">stringifyFns</span>:<span class="string">&quot;(fnObj = &#123; hello: () =&gt; &#x27;world&#x27; &#125;) =&gt; &#123;\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\n  // https://github.com/feross/fromentries\n  function fromEntries(iterable) &#123;\n    return [...iterable].reduce((obj, [key, val]) =&gt; &#123;\n      obj[key] = val\n      return obj\n    &#125;, &#123;&#125;)\n  &#125;\n  return (Object.fromEntries || fromEntries)(\n    Object.entries(fnObj)\n      .filter(([key, value]) =&gt; typeof value === &#x27;function&#x27;)\n      .map(([key, value]) =&gt; [key, value.toString()]) // eslint-disable-line no-eval\n  )\n&#125;&quot;</span>,<span class="attr">materializeFns</span>:<span class="string">&quot;(fnStrObj = &#123; hello: \&quot;() =&gt; &#x27;world&#x27;\&quot; &#125;) =&gt; &#123;\n  return Object.fromEntries(\n    Object.entries(fnStrObj).map(([key, value]) =&gt; &#123;\n      if (value.startsWith(&#x27;function&#x27;)) &#123;\n        // some trickery is needed to make oldschool functions work :-)\n        return [key, eval(`() =&gt; $&#123;value&#125;`)()] // eslint-disable-line no-eval\n      &#125; else &#123;\n        // arrow functions just work\n        return [key, eval(value)] // eslint-disable-line no-eval\n      &#125;\n    &#125;)\n  )\n&#125;&quot;</span>,<span class="attr">makeHandler</span>:<span class="string">&quot;() =&gt; (&#123;\n  // Used by simple `navigator` getter evasions\n  getterValue: value =&gt; (&#123;\n    apply(target, ctx, args) &#123;\n      // Let&#x27;s fetch the value first, to trigger and escalate potential errors\n      // Illegal invocations like `navigator.__proto__.vendor` will throw here\n      utils.cache.Reflect.apply(...arguments)\n      return value\n    &#125;\n  &#125;)\n&#125;)&quot;</span>,<span class="attr">arrayEquals</span>:<span class="string">&quot;(array1, array2) =&gt; &#123;\n  if (array1.length !== array2.length) &#123;\n    return false\n  &#125;\n  for (let i = 0; i &lt; array1.length; ++i) &#123;\n    if (array1[i] !== array2[i]) &#123;\n      return false\n    &#125;\n  &#125;\n  return true\n&#125;&quot;</span>,<span class="attr">memoize</span>:<span class="string">&quot;fn =&gt; &#123;\n  const cache = []\n  return function(...args) &#123;\n    if (!cache.some(c =&gt; utils.arrayEquals(c.key, args))) &#123;\n      cache.push(&#123; key: args, value: fn.apply(this, args) &#125;)\n    &#125;\n    return cache.find(c =&gt; utils.arrayEquals(c.key, args)).value\n  &#125;\n&#125;&quot;</span>&#125;,<span class="attr">_mainFunction</span>:<span class="string">&quot;(utils, &#123; opts &#125;) =&gt; &#123;\n        utils.replaceGetterWithProxy(\n          Object.getPrototypeOf(navigator),\n          &#x27;hardwareConcurrency&#x27;,\n          utils.makeHandler().getterValue(opts.hardwareConcurrency)\n        )\n      &#125;&quot;</span>,<span class="attr">_args</span>:[&#123;<span class="attr">opts</span>:&#123;<span class="attr">hardwareConcurrency</span>:<span class="number">4</span>&#125;&#125;]&#125;),(<span class="function">(<span class="params">&#123;_utilsFns:_utilsFns,_mainFunction:_mainFunction,_args:_args&#125;</span>)=&gt;</span>&#123;<span class="keyword">const</span> utils=<span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(_utilsFns).<span class="title function_">map</span>((<span class="function">(<span class="params">[key,value]</span>)=&gt;</span>[key,<span class="built_in">eval</span>(value)])));utils.<span class="title function_">init</span>(),<span class="built_in">eval</span>(_mainFunction)(utils,..._args)&#125;)(&#123;<span class="attr">_utilsFns</span>:&#123;<span class="attr">init</span>:<span class="string">&quot;() =&gt; &#123;\n  utils.preloadCache()\n&#125;&quot;</span>,<span class="attr">stripProxyFromErrors</span>:<span class="string">&quot;(handler = &#123;&#125;) =&gt; &#123;\n  const newHandler = &#123;\n    setPrototypeOf: function (target, proto) &#123;\n      if (proto === null)\n        throw new TypeError(&#x27;Cannot convert object to primitive value&#x27;)\n      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) &#123;\n        throw new TypeError(&#x27;Cyclic __proto__ value&#x27;)\n      &#125;\n      return Reflect.setPrototypeOf(target, proto)\n    &#125;\n  &#125;\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\n  const traps = Object.getOwnPropertyNames(handler)\n  traps.forEach(trap =&gt; &#123;\n    newHandler[trap] = function () &#123;\n      try &#123;\n        // Forward the call to the defined proxy handler\n        return handler[trap].apply(this, arguments || [])\n      &#125; catch (err) &#123;\n        // Stack traces differ per browser, we only support chromium based ones currently\n        if (!err || !err.stack || !err.stack.includes(`at `)) &#123;\n          throw err\n        &#125;\n\n        // When something throws within one of our traps the Proxy will show up in error stacks\n        // An earlier implementation of this code would simply strip lines with a blacklist,\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\n        // We try to use a known \&quot;anchor\&quot; line for that and strip it with everything above it.\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\n\n        const stripWithBlacklist = (stack, stripFirstLine = true) =&gt; &#123;\n          const blacklist = [\n            `at Reflect.$&#123;trap&#125; `, // e.g. Reflect.get or Reflect.apply\n            `at Object.$&#123;trap&#125; `, // e.g. Object.get or Object.apply\n            `at Object.newHandler.&lt;computed&gt; [as $&#123;trap&#125;] ` // caused by this very wrapper :-)\n          ]\n          return (\n            err.stack\n              .split(&#x27;\\n&#x27;)\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\n              .filter((line, index) =&gt; !(index === 1 &amp;&amp; stripFirstLine))\n              // Check if the line starts with one of our blacklisted strings\n              .filter(line =&gt; !blacklist.some(bl =&gt; line.trim().startsWith(bl)))\n              .join(&#x27;\\n&#x27;)\n          )\n        &#125;\n\n        const stripWithAnchor = (stack, anchor) =&gt; &#123;\n          const stackArr = stack.split(&#x27;\\n&#x27;)\n          anchor = anchor || `at Object.newHandler.&lt;computed&gt; [as $&#123;trap&#125;] ` // Known first Proxy line in chromium\n          const anchorIndex = stackArr.findIndex(line =&gt;\n            line.trim().startsWith(anchor)\n          )\n          if (anchorIndex === -1) &#123;\n            return false // 404, anchor not found\n          &#125;\n          // Strip everything from the top until we reach the anchor line\n          // Note: We&#x27;re keeping the 1st line (zero index) as it&#x27;s unrelated (e.g. `TypeError`)\n          stackArr.splice(1, anchorIndex)\n          return stackArr.join(&#x27;\\n&#x27;)\n        &#125;\n\n        // Special cases due to our nested toString proxies\n        err.stack = err.stack.replace(\n          &#x27;at Object.toString (&#x27;,\n          &#x27;at Function.toString (&#x27;\n        )\n        if ((err.stack || &#x27;&#x27;).includes(&#x27;at Function.toString (&#x27;)) &#123;\n          err.stack = stripWithBlacklist(err.stack, false)\n          throw err\n        &#125;\n\n        // Try using the anchor method, fallback to blacklist if necessary\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\n\n        throw err // Re-throw our now sanitized error\n      &#125;\n    &#125;\n  &#125;)\n  return newHandler\n&#125;&quot;</span>,<span class="attr">stripErrorWithAnchor</span>:<span class="string">&quot;(err, anchor) =&gt; &#123;\n  const stackArr = err.stack.split(&#x27;\\n&#x27;)\n  const anchorIndex = stackArr.findIndex(line =&gt; line.trim().startsWith(anchor))\n  if (anchorIndex === -1) &#123;\n    return err // 404, anchor not found\n  &#125;\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\n  // Note: We&#x27;re keeping the 1st line (zero index) as it&#x27;s unrelated (e.g. `TypeError`)\n  stackArr.splice(1, anchorIndex)\n  err.stack = stackArr.join(&#x27;\\n&#x27;)\n  return err\n&#125;&quot;</span>,<span class="attr">replaceProperty</span>:<span class="string">&quot;(obj, propName, descriptorOverrides = &#123;&#125;) =&gt; &#123;\n  return Object.defineProperty(obj, propName, &#123;\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || &#123;&#125;),\n    // Add our overrides (e.g. value, get())\n    ...descriptorOverrides\n  &#125;)\n&#125;&quot;</span>,<span class="attr">preloadCache</span>:<span class="string">&quot;() =&gt; &#123;\n  if (utils.cache) &#123;\n    return\n  &#125;\n  utils.cache = &#123;\n    // Used in our proxies\n    Reflect: &#123;\n      get: Reflect.get.bind(Reflect),\n      apply: Reflect.apply.bind(Reflect)\n    &#125;,\n    // Used in `makeNativeString`\n    nativeToStringStr: Function.toString + &#x27;&#x27; // =&gt; `function toString() &#123; [native code] &#125;`\n  &#125;\n&#125;&quot;</span>,<span class="attr">makeNativeString</span>:<span class="string">&quot;(name = &#x27;&#x27;) =&gt; &#123;\n  return utils.cache.nativeToStringStr.replace(&#x27;toString&#x27;, name || &#x27;&#x27;)\n&#125;&quot;</span>,<span class="attr">patchToString</span>:<span class="string">&quot;(obj, str = &#x27;&#x27;) =&gt; &#123;\n  const handler = &#123;\n    apply: function (target, ctx) &#123;\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \&quot;\&quot;`\n      if (ctx === Function.prototype.toString) &#123;\n        return utils.makeNativeString(&#x27;toString&#x27;)\n      &#125;\n      // `toString` targeted at our proxied Object detected\n      if (ctx === obj) &#123;\n        // We either return the optional string verbatim or derive the most desired result automatically\n        return str || utils.makeNativeString(obj.name)\n      &#125;\n      // Check if the toString protype of the context is the same as the global prototype,\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\n      const hasSameProto = Object.getPrototypeOf(\n        Function.prototype.toString\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\n      if (!hasSameProto) &#123;\n        // Pass the call on to the local Function.prototype.toString instead\n        return ctx.toString()\n      &#125;\n      return target.call(ctx)\n    &#125;\n  &#125;\n\n  const toStringProxy = new Proxy(\n    Function.prototype.toString,\n    utils.stripProxyFromErrors(handler)\n  )\n  utils.replaceProperty(Function.prototype, &#x27;toString&#x27;, &#123;\n    value: toStringProxy\n  &#125;)\n&#125;&quot;</span>,<span class="attr">patchToStringNested</span>:<span class="string">&quot;(obj = &#123;&#125;) =&gt; &#123;\n  return utils.execRecursively(obj, [&#x27;function&#x27;], utils.patchToString)\n&#125;&quot;</span>,<span class="attr">redirectToString</span>:<span class="string">&quot;(proxyObj, originalObj) =&gt; &#123;\n  const handler = &#123;\n    apply: function (target, ctx) &#123;\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \&quot;\&quot;`\n      if (ctx === Function.prototype.toString) &#123;\n        return utils.makeNativeString(&#x27;toString&#x27;)\n      &#125;\n\n      // `toString` targeted at our proxied Object detected\n      if (ctx === proxyObj) &#123;\n        const fallback = () =&gt;\n          originalObj &amp;&amp; originalObj.name\n            ? utils.makeNativeString(originalObj.name)\n            : utils.makeNativeString(proxyObj.name)\n\n        // Return the toString representation of our original object if possible\n        return originalObj + &#x27;&#x27; || fallback()\n      &#125;\n\n      if (typeof ctx === &#x27;undefined&#x27; || ctx === null) &#123;\n        return target.call(ctx)\n      &#125;\n\n      // Check if the toString protype of the context is the same as the global prototype,\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\n      const hasSameProto = Object.getPrototypeOf(\n        Function.prototype.toString\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\n      if (!hasSameProto) &#123;\n        // Pass the call on to the local Function.prototype.toString instead\n        return ctx.toString()\n      &#125;\n\n      return target.call(ctx)\n    &#125;\n  &#125;\n\n  const toStringProxy = new Proxy(\n    Function.prototype.toString,\n    utils.stripProxyFromErrors(handler)\n  )\n  utils.replaceProperty(Function.prototype, &#x27;toString&#x27;, &#123;\n    value: toStringProxy\n  &#125;)\n&#125;&quot;</span>,<span class="attr">replaceWithProxy</span>:<span class="string">&quot;(obj, propName, handler) =&gt; &#123;\n  const originalObj = obj[propName]\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, &#123; value: proxyObj &#125;)\n  utils.redirectToString(proxyObj, originalObj)\n\n  return true\n&#125;&quot;</span>,<span class="attr">replaceGetterWithProxy</span>:<span class="string">&quot;(obj, propName, handler) =&gt; &#123;\n  const fn = Object.getOwnPropertyDescriptor(obj, propName).get\n  const fnStr = fn.toString() // special getter function string\n  const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, &#123; get: proxyObj &#125;)\n  utils.patchToString(proxyObj, fnStr)\n\n  return true\n&#125;&quot;</span>,<span class="attr">replaceGetterSetter</span>:<span class="string">&quot;(obj, propName, handlerGetterSetter) =&gt; &#123;\n  const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)\n  const handler = &#123; ...ownPropertyDescriptor &#125;\n\n  if (handlerGetterSetter.get !== undefined) &#123;\n    const nativeFn = ownPropertyDescriptor.get\n    handler.get = function() &#123;\n      return handlerGetterSetter.get.call(this, nativeFn.bind(this))\n    &#125;\n    utils.redirectToString(handler.get, nativeFn)\n  &#125;\n\n  if (handlerGetterSetter.set !== undefined) &#123;\n    const nativeFn = ownPropertyDescriptor.set\n    handler.set = function(newValue) &#123;\n      handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this))\n    &#125;\n    utils.redirectToString(handler.set, nativeFn)\n  &#125;\n\n  Object.defineProperty(obj, propName, handler)\n&#125;&quot;</span>,<span class="attr">mockWithProxy</span>:<span class="string">&quot;(obj, propName, pseudoTarget, handler) =&gt; &#123;\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, &#123; value: proxyObj &#125;)\n  utils.patchToString(proxyObj)\n\n  return true\n&#125;&quot;</span>,<span class="attr">createProxy</span>:<span class="string">&quot;(pseudoTarget, handler) =&gt; &#123;\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\n  utils.patchToString(proxyObj)\n\n  return proxyObj\n&#125;&quot;</span>,<span class="attr">splitObjPath</span>:<span class="string">&quot;objPath =&gt; (&#123;\n  // Remove last dot entry (property) ==&gt; `HTMLMediaElement.prototype`\n  objName: objPath.split(&#x27;.&#x27;).slice(0, -1).join(&#x27;.&#x27;),\n  // Extract last dot entry ==&gt; `canPlayType`\n  propName: objPath.split(&#x27;.&#x27;).slice(-1)[0]\n&#125;)&quot;</span>,<span class="attr">replaceObjPathWithProxy</span>:<span class="string">&quot;(objPath, handler) =&gt; &#123;\n  const &#123; objName, propName &#125; = utils.splitObjPath(objPath)\n  const obj = eval(objName) // eslint-disable-line no-eval\n  return utils.replaceWithProxy(obj, propName, handler)\n&#125;&quot;</span>,<span class="attr">execRecursively</span>:<span class="string">&quot;(obj = &#123;&#125;, typeFilter = [], fn) =&gt; &#123;\n  function recurse(obj) &#123;\n    for (const key in obj) &#123;\n      if (obj[key] === undefined) &#123;\n        continue\n      &#125;\n      if (obj[key] &amp;&amp; typeof obj[key] === &#x27;object&#x27;) &#123;\n        recurse(obj[key])\n      &#125; else &#123;\n        if (obj[key] &amp;&amp; typeFilter.includes(typeof obj[key])) &#123;\n          fn.call(this, obj[key])\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n  recurse(obj)\n  return obj\n&#125;&quot;</span>,<span class="attr">stringifyFns</span>:<span class="string">&quot;(fnObj = &#123; hello: () =&gt; &#x27;world&#x27; &#125;) =&gt; &#123;\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\n  // https://github.com/feross/fromentries\n  function fromEntries(iterable) &#123;\n    return [...iterable].reduce((obj, [key, val]) =&gt; &#123;\n      obj[key] = val\n      return obj\n    &#125;, &#123;&#125;)\n  &#125;\n  return (Object.fromEntries || fromEntries)(\n    Object.entries(fnObj)\n      .filter(([key, value]) =&gt; typeof value === &#x27;function&#x27;)\n      .map(([key, value]) =&gt; [key, value.toString()]) // eslint-disable-line no-eval\n  )\n&#125;&quot;</span>,<span class="attr">materializeFns</span>:<span class="string">&quot;(fnStrObj = &#123; hello: \&quot;() =&gt; &#x27;world&#x27;\&quot; &#125;) =&gt; &#123;\n  return Object.fromEntries(\n    Object.entries(fnStrObj).map(([key, value]) =&gt; &#123;\n      if (value.startsWith(&#x27;function&#x27;)) &#123;\n        // some trickery is needed to make oldschool functions work :-)\n        return [key, eval(`() =&gt; $&#123;value&#125;`)()] // eslint-disable-line no-eval\n      &#125; else &#123;\n        // arrow functions just work\n        return [key, eval(value)] // eslint-disable-line no-eval\n      &#125;\n    &#125;)\n  )\n&#125;&quot;</span>,<span class="attr">makeHandler</span>:<span class="string">&quot;() =&gt; (&#123;\n  // Used by simple `navigator` getter evasions\n  getterValue: value =&gt; (&#123;\n    apply(target, ctx, args) &#123;\n      // Let&#x27;s fetch the value first, to trigger and escalate potential errors\n      // Illegal invocations like `navigator.__proto__.vendor` will throw here\n      utils.cache.Reflect.apply(...arguments)\n      return value\n    &#125;\n  &#125;)\n&#125;)&quot;</span>,<span class="attr">arrayEquals</span>:<span class="string">&quot;(array1, array2) =&gt; &#123;\n  if (array1.length !== array2.length) &#123;\n    return false\n  &#125;\n  for (let i = 0; i &lt; array1.length; ++i) &#123;\n    if (array1[i] !== array2[i]) &#123;\n      return false\n    &#125;\n  &#125;\n  return true\n&#125;&quot;</span>,<span class="attr">memoize</span>:<span class="string">&quot;fn =&gt; &#123;\n  const cache = []\n  return function(...args) &#123;\n    if (!cache.some(c =&gt; utils.arrayEquals(c.key, args))) &#123;\n      cache.push(&#123; key: args, value: fn.apply(this, args) &#125;)\n    &#125;\n    return cache.find(c =&gt; utils.arrayEquals(c.key, args)).value\n  &#125;\n&#125;&quot;</span>&#125;,<span class="attr">_mainFunction</span>:<span class="string">&quot;(utils, &#123; opts &#125;) =&gt; &#123;\n        const languages = opts.languages.length\n          ? opts.languages\n          : [&#x27;en-US&#x27;, &#x27;en&#x27;]\n        utils.replaceGetterWithProxy(\n          Object.getPrototypeOf(navigator),\n          &#x27;languages&#x27;,\n          utils.makeHandler().getterValue(Object.freeze([...languages]))\n        )\n      &#125;&quot;</span>,<span class="attr">_args</span>:[&#123;<span class="attr">opts</span>:&#123;<span class="attr">languages</span>:[]&#125;&#125;]&#125;),(<span class="function">(<span class="params">&#123;_utilsFns:_utilsFns,_mainFunction:_mainFunction,_args:_args&#125;</span>)=&gt;</span>&#123;<span class="keyword">const</span> utils=<span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(_utilsFns).<span class="title function_">map</span>((<span class="function">(<span class="params">[key,value]</span>)=&gt;</span>[key,<span class="built_in">eval</span>(value)])));utils.<span class="title function_">init</span>(),<span class="built_in">eval</span>(_mainFunction)(utils,..._args)&#125;)(&#123;<span class="attr">_utilsFns</span>:&#123;<span class="attr">init</span>:<span class="string">&quot;() =&gt; &#123;\n  utils.preloadCache()\n&#125;&quot;</span>,<span class="attr">stripProxyFromErrors</span>:<span class="string">&quot;(handler = &#123;&#125;) =&gt; &#123;\n  const newHandler = &#123;\n    setPrototypeOf: function (target, proto) &#123;\n      if (proto === null)\n        throw new TypeError(&#x27;Cannot convert object to primitive value&#x27;)\n      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) &#123;\n        throw new TypeError(&#x27;Cyclic __proto__ value&#x27;)\n      &#125;\n      return Reflect.setPrototypeOf(target, proto)\n    &#125;\n  &#125;\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\n  const traps = Object.getOwnPropertyNames(handler)\n  traps.forEach(trap =&gt; &#123;\n    newHandler[trap] = function () &#123;\n      try &#123;\n        // Forward the call to the defined proxy handler\n        return handler[trap].apply(this, arguments || [])\n      &#125; catch (err) &#123;\n        // Stack traces differ per browser, we only support chromium based ones currently\n        if (!err || !err.stack || !err.stack.includes(`at `)) &#123;\n          throw err\n        &#125;\n\n        // When something throws within one of our traps the Proxy will show up in error stacks\n        // An earlier implementation of this code would simply strip lines with a blacklist,\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\n        // We try to use a known \&quot;anchor\&quot; line for that and strip it with everything above it.\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\n\n        const stripWithBlacklist = (stack, stripFirstLine = true) =&gt; &#123;\n          const blacklist = [\n            `at Reflect.$&#123;trap&#125; `, // e.g. Reflect.get or Reflect.apply\n            `at Object.$&#123;trap&#125; `, // e.g. Object.get or Object.apply\n            `at Object.newHandler.&lt;computed&gt; [as $&#123;trap&#125;] ` // caused by this very wrapper :-)\n          ]\n          return (\n            err.stack\n              .split(&#x27;\\n&#x27;)\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\n              .filter((line, index) =&gt; !(index === 1 &amp;&amp; stripFirstLine))\n              // Check if the line starts with one of our blacklisted strings\n              .filter(line =&gt; !blacklist.some(bl =&gt; line.trim().startsWith(bl)))\n              .join(&#x27;\\n&#x27;)\n          )\n        &#125;\n\n        const stripWithAnchor = (stack, anchor) =&gt; &#123;\n          const stackArr = stack.split(&#x27;\\n&#x27;)\n          anchor = anchor || `at Object.newHandler.&lt;computed&gt; [as $&#123;trap&#125;] ` // Known first Proxy line in chromium\n          const anchorIndex = stackArr.findIndex(line =&gt;\n            line.trim().startsWith(anchor)\n          )\n          if (anchorIndex === -1) &#123;\n            return false // 404, anchor not found\n          &#125;\n          // Strip everything from the top until we reach the anchor line\n          // Note: We&#x27;re keeping the 1st line (zero index) as it&#x27;s unrelated (e.g. `TypeError`)\n          stackArr.splice(1, anchorIndex)\n          return stackArr.join(&#x27;\\n&#x27;)\n        &#125;\n\n        // Special cases due to our nested toString proxies\n        err.stack = err.stack.replace(\n          &#x27;at Object.toString (&#x27;,\n          &#x27;at Function.toString (&#x27;\n        )\n        if ((err.stack || &#x27;&#x27;).includes(&#x27;at Function.toString (&#x27;)) &#123;\n          err.stack = stripWithBlacklist(err.stack, false)\n          throw err\n        &#125;\n\n        // Try using the anchor method, fallback to blacklist if necessary\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\n\n        throw err // Re-throw our now sanitized error\n      &#125;\n    &#125;\n  &#125;)\n  return newHandler\n&#125;&quot;</span>,<span class="attr">stripErrorWithAnchor</span>:<span class="string">&quot;(err, anchor) =&gt; &#123;\n  const stackArr = err.stack.split(&#x27;\\n&#x27;)\n  const anchorIndex = stackArr.findIndex(line =&gt; line.trim().startsWith(anchor))\n  if (anchorIndex === -1) &#123;\n    return err // 404, anchor not found\n  &#125;\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\n  // Note: We&#x27;re keeping the 1st line (zero index) as it&#x27;s unrelated (e.g. `TypeError`)\n  stackArr.splice(1, anchorIndex)\n  err.stack = stackArr.join(&#x27;\\n&#x27;)\n  return err\n&#125;&quot;</span>,<span class="attr">replaceProperty</span>:<span class="string">&quot;(obj, propName, descriptorOverrides = &#123;&#125;) =&gt; &#123;\n  return Object.defineProperty(obj, propName, &#123;\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || &#123;&#125;),\n    // Add our overrides (e.g. value, get())\n    ...descriptorOverrides\n  &#125;)\n&#125;&quot;</span>,<span class="attr">preloadCache</span>:<span class="string">&quot;() =&gt; &#123;\n  if (utils.cache) &#123;\n    return\n  &#125;\n  utils.cache = &#123;\n    // Used in our proxies\n    Reflect: &#123;\n      get: Reflect.get.bind(Reflect),\n      apply: Reflect.apply.bind(Reflect)\n    &#125;,\n    // Used in `makeNativeString`\n    nativeToStringStr: Function.toString + &#x27;&#x27; // =&gt; `function toString() &#123; [native code] &#125;`\n  &#125;\n&#125;&quot;</span>,<span class="attr">makeNativeString</span>:<span class="string">&quot;(name = &#x27;&#x27;) =&gt; &#123;\n  return utils.cache.nativeToStringStr.replace(&#x27;toString&#x27;, name || &#x27;&#x27;)\n&#125;&quot;</span>,<span class="attr">patchToString</span>:<span class="string">&quot;(obj, str = &#x27;&#x27;) =&gt; &#123;\n  const handler = &#123;\n    apply: function (target, ctx) &#123;\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \&quot;\&quot;`\n      if (ctx === Function.prototype.toString) &#123;\n        return utils.makeNativeString(&#x27;toString&#x27;)\n      &#125;\n      // `toString` targeted at our proxied Object detected\n      if (ctx === obj) &#123;\n        // We either return the optional string verbatim or derive the most desired result automatically\n        return str || utils.makeNativeString(obj.name)\n      &#125;\n      // Check if the toString protype of the context is the same as the global prototype,\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\n      const hasSameProto = Object.getPrototypeOf(\n        Function.prototype.toString\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\n      if (!hasSameProto) &#123;\n        // Pass the call on to the local Function.prototype.toString instead\n        return ctx.toString()\n      &#125;\n      return target.call(ctx)\n    &#125;\n  &#125;\n\n  const toStringProxy = new Proxy(\n    Function.prototype.toString,\n    utils.stripProxyFromErrors(handler)\n  )\n  utils.replaceProperty(Function.prototype, &#x27;toString&#x27;, &#123;\n    value: toStringProxy\n  &#125;)\n&#125;&quot;</span>,<span class="attr">patchToStringNested</span>:<span class="string">&quot;(obj = &#123;&#125;) =&gt; &#123;\n  return utils.execRecursively(obj, [&#x27;function&#x27;], utils.patchToString)\n&#125;&quot;</span>,<span class="attr">redirectToString</span>:<span class="string">&quot;(proxyObj, originalObj) =&gt; &#123;\n  const handler = &#123;\n    apply: function (target, ctx) &#123;\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \&quot;\&quot;`\n      if (ctx === Function.prototype.toString) &#123;\n        return utils.makeNativeString(&#x27;toString&#x27;)\n      &#125;\n\n      // `toString` targeted at our proxied Object detected\n      if (ctx === proxyObj) &#123;\n        const fallback = () =&gt;\n          originalObj &amp;&amp; originalObj.name\n            ? utils.makeNativeString(originalObj.name)\n            : utils.makeNativeString(proxyObj.name)\n\n        // Return the toString representation of our original object if possible\n        return originalObj + &#x27;&#x27; || fallback()\n      &#125;\n\n      if (typeof ctx === &#x27;undefined&#x27; || ctx === null) &#123;\n        return target.call(ctx)\n      &#125;\n\n      // Check if the toString protype of the context is the same as the global prototype,\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\n      const hasSameProto = Object.getPrototypeOf(\n        Function.prototype.toString\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\n      if (!hasSameProto) &#123;\n        // Pass the call on to the local Function.prototype.toString instead\n        return ctx.toString()\n      &#125;\n\n      return target.call(ctx)\n    &#125;\n  &#125;\n\n  const toStringProxy = new Proxy(\n    Function.prototype.toString,\n    utils.stripProxyFromErrors(handler)\n  )\n  utils.replaceProperty(Function.prototype, &#x27;toString&#x27;, &#123;\n    value: toStringProxy\n  &#125;)\n&#125;&quot;</span>,<span class="attr">replaceWithProxy</span>:<span class="string">&quot;(obj, propName, handler) =&gt; &#123;\n  const originalObj = obj[propName]\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, &#123; value: proxyObj &#125;)\n  utils.redirectToString(proxyObj, originalObj)\n\n  return true\n&#125;&quot;</span>,<span class="attr">replaceGetterWithProxy</span>:<span class="string">&quot;(obj, propName, handler) =&gt; &#123;\n  const fn = Object.getOwnPropertyDescriptor(obj, propName).get\n  const fnStr = fn.toString() // special getter function string\n  const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, &#123; get: proxyObj &#125;)\n  utils.patchToString(proxyObj, fnStr)\n\n  return true\n&#125;&quot;</span>,<span class="attr">replaceGetterSetter</span>:<span class="string">&quot;(obj, propName, handlerGetterSetter) =&gt; &#123;\n  const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)\n  const handler = &#123; ...ownPropertyDescriptor &#125;\n\n  if (handlerGetterSetter.get !== undefined) &#123;\n    const nativeFn = ownPropertyDescriptor.get\n    handler.get = function() &#123;\n      return handlerGetterSetter.get.call(this, nativeFn.bind(this))\n    &#125;\n    utils.redirectToString(handler.get, nativeFn)\n  &#125;\n\n  if (handlerGetterSetter.set !== undefined) &#123;\n    const nativeFn = ownPropertyDescriptor.set\n    handler.set = function(newValue) &#123;\n      handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this))\n    &#125;\n    utils.redirectToString(handler.set, nativeFn)\n  &#125;\n\n  Object.defineProperty(obj, propName, handler)\n&#125;&quot;</span>,<span class="attr">mockWithProxy</span>:<span class="string">&quot;(obj, propName, pseudoTarget, handler) =&gt; &#123;\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, &#123; value: proxyObj &#125;)\n  utils.patchToString(proxyObj)\n\n  return true\n&#125;&quot;</span>,<span class="attr">createProxy</span>:<span class="string">&quot;(pseudoTarget, handler) =&gt; &#123;\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\n  utils.patchToString(proxyObj)\n\n  return proxyObj\n&#125;&quot;</span>,<span class="attr">splitObjPath</span>:<span class="string">&quot;objPath =&gt; (&#123;\n  // Remove last dot entry (property) ==&gt; `HTMLMediaElement.prototype`\n  objName: objPath.split(&#x27;.&#x27;).slice(0, -1).join(&#x27;.&#x27;),\n  // Extract last dot entry ==&gt; `canPlayType`\n  propName: objPath.split(&#x27;.&#x27;).slice(-1)[0]\n&#125;)&quot;</span>,<span class="attr">replaceObjPathWithProxy</span>:<span class="string">&quot;(objPath, handler) =&gt; &#123;\n  const &#123; objName, propName &#125; = utils.splitObjPath(objPath)\n  const obj = eval(objName) // eslint-disable-line no-eval\n  return utils.replaceWithProxy(obj, propName, handler)\n&#125;&quot;</span>,<span class="attr">execRecursively</span>:<span class="string">&quot;(obj = &#123;&#125;, typeFilter = [], fn) =&gt; &#123;\n  function recurse(obj) &#123;\n    for (const key in obj) &#123;\n      if (obj[key] === undefined) &#123;\n        continue\n      &#125;\n      if (obj[key] &amp;&amp; typeof obj[key] === &#x27;object&#x27;) &#123;\n        recurse(obj[key])\n      &#125; else &#123;\n        if (obj[key] &amp;&amp; typeFilter.includes(typeof obj[key])) &#123;\n          fn.call(this, obj[key])\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n  recurse(obj)\n  return obj\n&#125;&quot;</span>,<span class="attr">stringifyFns</span>:<span class="string">&quot;(fnObj = &#123; hello: () =&gt; &#x27;world&#x27; &#125;) =&gt; &#123;\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\n  // https://github.com/feross/fromentries\n  function fromEntries(iterable) &#123;\n    return [...iterable].reduce((obj, [key, val]) =&gt; &#123;\n      obj[key] = val\n      return obj\n    &#125;, &#123;&#125;)\n  &#125;\n  return (Object.fromEntries || fromEntries)(\n    Object.entries(fnObj)\n      .filter(([key, value]) =&gt; typeof value === &#x27;function&#x27;)\n      .map(([key, value]) =&gt; [key, value.toString()]) // eslint-disable-line no-eval\n  )\n&#125;&quot;</span>,<span class="attr">materializeFns</span>:<span class="string">&quot;(fnStrObj = &#123; hello: \&quot;() =&gt; &#x27;world&#x27;\&quot; &#125;) =&gt; &#123;\n  return Object.fromEntries(\n    Object.entries(fnStrObj).map(([key, value]) =&gt; &#123;\n      if (value.startsWith(&#x27;function&#x27;)) &#123;\n        // some trickery is needed to make oldschool functions work :-)\n        return [key, eval(`() =&gt; $&#123;value&#125;`)()] // eslint-disable-line no-eval\n      &#125; else &#123;\n        // arrow functions just work\n        return [key, eval(value)] // eslint-disable-line no-eval\n      &#125;\n    &#125;)\n  )\n&#125;&quot;</span>,<span class="attr">makeHandler</span>:<span class="string">&quot;() =&gt; (&#123;\n  // Used by simple `navigator` getter evasions\n  getterValue: value =&gt; (&#123;\n    apply(target, ctx, args) &#123;\n      // Let&#x27;s fetch the value first, to trigger and escalate potential errors\n      // Illegal invocations like `navigator.__proto__.vendor` will throw here\n      utils.cache.Reflect.apply(...arguments)\n      return value\n    &#125;\n  &#125;)\n&#125;)&quot;</span>,<span class="attr">arrayEquals</span>:<span class="string">&quot;(array1, array2) =&gt; &#123;\n  if (array1.length !== array2.length) &#123;\n    return false\n  &#125;\n  for (let i = 0; i &lt; array1.length; ++i) &#123;\n    if (array1[i] !== array2[i]) &#123;\n      return false\n    &#125;\n  &#125;\n  return true\n&#125;&quot;</span>,<span class="attr">memoize</span>:<span class="string">&quot;fn =&gt; &#123;\n  const cache = []\n  return function(...args) &#123;\n    if (!cache.some(c =&gt; utils.arrayEquals(c.key, args))) &#123;\n      cache.push(&#123; key: args, value: fn.apply(this, args) &#125;)\n    &#125;\n    return cache.find(c =&gt; utils.arrayEquals(c.key, args)).value\n  &#125;\n&#125;&quot;</span>&#125;,<span class="attr">_mainFunction</span>:<span class="string">&quot;(utils, opts) =&gt; &#123;\n      const isSecure = document.location.protocol.startsWith(&#x27;https&#x27;)\n\n      // In headful on secure origins the permission should be \&quot;default\&quot;, not \&quot;denied\&quot;\n      if (isSecure) &#123;\n        utils.replaceGetterWithProxy(Notification, &#x27;permission&#x27;, &#123;\n          apply() &#123;\n            return &#x27;default&#x27;\n          &#125;\n        &#125;)\n      &#125;\n\n      // Another weird behavior:\n      // On insecure origins in headful the state is \&quot;denied\&quot;,\n      // whereas in headless it&#x27;s \&quot;prompt\&quot;\n      if (!isSecure) &#123;\n        const handler = &#123;\n          apply(target, ctx, args) &#123;\n            const param = (args || [])[0]\n\n            const isNotifications =\n              param &amp;&amp; param.name &amp;&amp; param.name === &#x27;notifications&#x27;\n            if (!isNotifications) &#123;\n              return utils.cache.Reflect.apply(...arguments)\n            &#125;\n\n            return Promise.resolve(\n              Object.setPrototypeOf(\n                &#123;\n                  state: &#x27;denied&#x27;,\n                  onchange: null\n                &#125;,\n                PermissionStatus.prototype\n              )\n            )\n          &#125;\n        &#125;\n        // Note: Don&#x27;t use `Object.getPrototypeOf` here\n        utils.replaceWithProxy(Permissions.prototype, &#x27;query&#x27;, handler)\n      &#125;\n    &#125;&quot;</span>,<span class="attr">_args</span>:[&#123;&#125;]&#125;),(<span class="function">(<span class="params">&#123;_utilsFns:_utilsFns,_mainFunction:_mainFunction,_args:_args&#125;</span>)=&gt;</span>&#123;<span class="keyword">const</span> utils=<span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(_utilsFns).<span class="title function_">map</span>((<span class="function">(<span class="params">[key,value]</span>)=&gt;</span>[key,<span class="built_in">eval</span>(value)])));utils.<span class="title function_">init</span>(),<span class="built_in">eval</span>(_mainFunction)(utils,..._args)&#125;)(&#123;<span class="attr">_utilsFns</span>:&#123;<span class="attr">init</span>:<span class="string">&quot;() =&gt; &#123;\n  utils.preloadCache()\n&#125;&quot;</span>,<span class="attr">stripProxyFromErrors</span>:<span class="string">&quot;(handler = &#123;&#125;) =&gt; &#123;\n  const newHandler = &#123;\n    setPrototypeOf: function (target, proto) &#123;\n      if (proto === null)\n        throw new TypeError(&#x27;Cannot convert object to primitive value&#x27;)\n      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) &#123;\n        throw new TypeError(&#x27;Cyclic __proto__ value&#x27;)\n      &#125;\n      return Reflect.setPrototypeOf(target, proto)\n    &#125;\n  &#125;\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\n  const traps = Object.getOwnPropertyNames(handler)\n  traps.forEach(trap =&gt; &#123;\n    newHandler[trap] = function () &#123;\n      try &#123;\n        // Forward the call to the defined proxy handler\n        return handler[trap].apply(this, arguments || [])\n      &#125; catch (err) &#123;\n        // Stack traces differ per browser, we only support chromium based ones currently\n        if (!err || !err.stack || !err.stack.includes(`at `)) &#123;\n          throw err\n        &#125;\n\n        // When something throws within one of our traps the Proxy will show up in error stacks\n        // An earlier implementation of this code would simply strip lines with a blacklist,\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\n        // We try to use a known \&quot;anchor\&quot; line for that and strip it with everything above it.\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\n\n        const stripWithBlacklist = (stack, stripFirstLine = true) =&gt; &#123;\n          const blacklist = [\n            `at Reflect.$&#123;trap&#125; `, // e.g. Reflect.get or Reflect.apply\n            `at Object.$&#123;trap&#125; `, // e.g. Object.get or Object.apply\n            `at Object.newHandler.&lt;computed&gt; [as $&#123;trap&#125;] ` // caused by this very wrapper :-)\n          ]\n          return (\n            err.stack\n              .split(&#x27;\\n&#x27;)\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\n              .filter((line, index) =&gt; !(index === 1 &amp;&amp; stripFirstLine))\n              // Check if the line starts with one of our blacklisted strings\n              .filter(line =&gt; !blacklist.some(bl =&gt; line.trim().startsWith(bl)))\n              .join(&#x27;\\n&#x27;)\n          )\n        &#125;\n\n        const stripWithAnchor = (stack, anchor) =&gt; &#123;\n          const stackArr = stack.split(&#x27;\\n&#x27;)\n          anchor = anchor || `at Object.newHandler.&lt;computed&gt; [as $&#123;trap&#125;] ` // Known first Proxy line in chromium\n          const anchorIndex = stackArr.findIndex(line =&gt;\n            line.trim().startsWith(anchor)\n          )\n          if (anchorIndex === -1) &#123;\n            return false // 404, anchor not found\n          &#125;\n          // Strip everything from the top until we reach the anchor line\n          // Note: We&#x27;re keeping the 1st line (zero index) as it&#x27;s unrelated (e.g. `TypeError`)\n          stackArr.splice(1, anchorIndex)\n          return stackArr.join(&#x27;\\n&#x27;)\n        &#125;\n\n        // Special cases due to our nested toString proxies\n        err.stack = err.stack.replace(\n          &#x27;at Object.toString (&#x27;,\n          &#x27;at Function.toString (&#x27;\n        )\n        if ((err.stack || &#x27;&#x27;).includes(&#x27;at Function.toString (&#x27;)) &#123;\n          err.stack = stripWithBlacklist(err.stack, false)\n          throw err\n        &#125;\n\n        // Try using the anchor method, fallback to blacklist if necessary\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\n\n        throw err // Re-throw our now sanitized error\n      &#125;\n    &#125;\n  &#125;)\n  return newHandler\n&#125;&quot;</span>,<span class="attr">stripErrorWithAnchor</span>:<span class="string">&quot;(err, anchor) =&gt; &#123;\n  const stackArr = err.stack.split(&#x27;\\n&#x27;)\n  const anchorIndex = stackArr.findIndex(line =&gt; line.trim().startsWith(anchor))\n  if (anchorIndex === -1) &#123;\n    return err // 404, anchor not found\n  &#125;\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\n  // Note: We&#x27;re keeping the 1st line (zero index) as it&#x27;s unrelated (e.g. `TypeError`)\n  stackArr.splice(1, anchorIndex)\n  err.stack = stackArr.join(&#x27;\\n&#x27;)\n  return err\n&#125;&quot;</span>,<span class="attr">replaceProperty</span>:<span class="string">&quot;(obj, propName, descriptorOverrides = &#123;&#125;) =&gt; &#123;\n  return Object.defineProperty(obj, propName, &#123;\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || &#123;&#125;),\n    // Add our overrides (e.g. value, get())\n    ...descriptorOverrides\n  &#125;)\n&#125;&quot;</span>,<span class="attr">preloadCache</span>:<span class="string">&quot;() =&gt; &#123;\n  if (utils.cache) &#123;\n    return\n  &#125;\n  utils.cache = &#123;\n    // Used in our proxies\n    Reflect: &#123;\n      get: Reflect.get.bind(Reflect),\n      apply: Reflect.apply.bind(Reflect)\n    &#125;,\n    // Used in `makeNativeString`\n    nativeToStringStr: Function.toString + &#x27;&#x27; // =&gt; `function toString() &#123; [native code] &#125;`\n  &#125;\n&#125;&quot;</span>,<span class="attr">makeNativeString</span>:<span class="string">&quot;(name = &#x27;&#x27;) =&gt; &#123;\n  return utils.cache.nativeToStringStr.replace(&#x27;toString&#x27;, name || &#x27;&#x27;)\n&#125;&quot;</span>,<span class="attr">patchToString</span>:<span class="string">&quot;(obj, str = &#x27;&#x27;) =&gt; &#123;\n  const handler = &#123;\n    apply: function (target, ctx) &#123;\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \&quot;\&quot;`\n      if (ctx === Function.prototype.toString) &#123;\n        return utils.makeNativeString(&#x27;toString&#x27;)\n      &#125;\n      // `toString` targeted at our proxied Object detected\n      if (ctx === obj) &#123;\n        // We either return the optional string verbatim or derive the most desired result automatically\n        return str || utils.makeNativeString(obj.name)\n      &#125;\n      // Check if the toString protype of the context is the same as the global prototype,\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\n      const hasSameProto = Object.getPrototypeOf(\n        Function.prototype.toString\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\n      if (!hasSameProto) &#123;\n        // Pass the call on to the local Function.prototype.toString instead\n        return ctx.toString()\n      &#125;\n      return target.call(ctx)\n    &#125;\n  &#125;\n\n  const toStringProxy = new Proxy(\n    Function.prototype.toString,\n    utils.stripProxyFromErrors(handler)\n  )\n  utils.replaceProperty(Function.prototype, &#x27;toString&#x27;, &#123;\n    value: toStringProxy\n  &#125;)\n&#125;&quot;</span>,<span class="attr">patchToStringNested</span>:<span class="string">&quot;(obj = &#123;&#125;) =&gt; &#123;\n  return utils.execRecursively(obj, [&#x27;function&#x27;], utils.patchToString)\n&#125;&quot;</span>,<span class="attr">redirectToString</span>:<span class="string">&quot;(proxyObj, originalObj) =&gt; &#123;\n  const handler = &#123;\n    apply: function (target, ctx) &#123;\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \&quot;\&quot;`\n      if (ctx === Function.prototype.toString) &#123;\n        return utils.makeNativeString(&#x27;toString&#x27;)\n      &#125;\n\n      // `toString` targeted at our proxied Object detected\n      if (ctx === proxyObj) &#123;\n        const fallback = () =&gt;\n          originalObj &amp;&amp; originalObj.name\n            ? utils.makeNativeString(originalObj.name)\n            : utils.makeNativeString(proxyObj.name)\n\n        // Return the toString representation of our original object if possible\n        return originalObj + &#x27;&#x27; || fallback()\n      &#125;\n\n      if (typeof ctx === &#x27;undefined&#x27; || ctx === null) &#123;\n        return target.call(ctx)\n      &#125;\n\n      // Check if the toString protype of the context is the same as the global prototype,\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\n      const hasSameProto = Object.getPrototypeOf(\n        Function.prototype.toString\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\n      if (!hasSameProto) &#123;\n        // Pass the call on to the local Function.prototype.toString instead\n        return ctx.toString()\n      &#125;\n\n      return target.call(ctx)\n    &#125;\n  &#125;\n\n  const toStringProxy = new Proxy(\n    Function.prototype.toString,\n    utils.stripProxyFromErrors(handler)\n  )\n  utils.replaceProperty(Function.prototype, &#x27;toString&#x27;, &#123;\n    value: toStringProxy\n  &#125;)\n&#125;&quot;</span>,<span class="attr">replaceWithProxy</span>:<span class="string">&quot;(obj, propName, handler) =&gt; &#123;\n  const originalObj = obj[propName]\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, &#123; value: proxyObj &#125;)\n  utils.redirectToString(proxyObj, originalObj)\n\n  return true\n&#125;&quot;</span>,<span class="attr">replaceGetterWithProxy</span>:<span class="string">&quot;(obj, propName, handler) =&gt; &#123;\n  const fn = Object.getOwnPropertyDescriptor(obj, propName).get\n  const fnStr = fn.toString() // special getter function string\n  const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, &#123; get: proxyObj &#125;)\n  utils.patchToString(proxyObj, fnStr)\n\n  return true\n&#125;&quot;</span>,<span class="attr">replaceGetterSetter</span>:<span class="string">&quot;(obj, propName, handlerGetterSetter) =&gt; &#123;\n  const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)\n  const handler = &#123; ...ownPropertyDescriptor &#125;\n\n  if (handlerGetterSetter.get !== undefined) &#123;\n    const nativeFn = ownPropertyDescriptor.get\n    handler.get = function() &#123;\n      return handlerGetterSetter.get.call(this, nativeFn.bind(this))\n    &#125;\n    utils.redirectToString(handler.get, nativeFn)\n  &#125;\n\n  if (handlerGetterSetter.set !== undefined) &#123;\n    const nativeFn = ownPropertyDescriptor.set\n    handler.set = function(newValue) &#123;\n      handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this))\n    &#125;\n    utils.redirectToString(handler.set, nativeFn)\n  &#125;\n\n  Object.defineProperty(obj, propName, handler)\n&#125;&quot;</span>,<span class="attr">mockWithProxy</span>:<span class="string">&quot;(obj, propName, pseudoTarget, handler) =&gt; &#123;\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, &#123; value: proxyObj &#125;)\n  utils.patchToString(proxyObj)\n\n  return true\n&#125;&quot;</span>,<span class="attr">createProxy</span>:<span class="string">&quot;(pseudoTarget, handler) =&gt; &#123;\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\n  utils.patchToString(proxyObj)\n\n  return proxyObj\n&#125;&quot;</span>,<span class="attr">splitObjPath</span>:<span class="string">&quot;objPath =&gt; (&#123;\n  // Remove last dot entry (property) ==&gt; `HTMLMediaElement.prototype`\n  objName: objPath.split(&#x27;.&#x27;).slice(0, -1).join(&#x27;.&#x27;),\n  // Extract last dot entry ==&gt; `canPlayType`\n  propName: objPath.split(&#x27;.&#x27;).slice(-1)[0]\n&#125;)&quot;</span>,<span class="attr">replaceObjPathWithProxy</span>:<span class="string">&quot;(objPath, handler) =&gt; &#123;\n  const &#123; objName, propName &#125; = utils.splitObjPath(objPath)\n  const obj = eval(objName) // eslint-disable-line no-eval\n  return utils.replaceWithProxy(obj, propName, handler)\n&#125;&quot;</span>,<span class="attr">execRecursively</span>:<span class="string">&quot;(obj = &#123;&#125;, typeFilter = [], fn) =&gt; &#123;\n  function recurse(obj) &#123;\n    for (const key in obj) &#123;\n      if (obj[key] === undefined) &#123;\n        continue\n      &#125;\n      if (obj[key] &amp;&amp; typeof obj[key] === &#x27;object&#x27;) &#123;\n        recurse(obj[key])\n      &#125; else &#123;\n        if (obj[key] &amp;&amp; typeFilter.includes(typeof obj[key])) &#123;\n          fn.call(this, obj[key])\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n  recurse(obj)\n  return obj\n&#125;&quot;</span>,<span class="attr">stringifyFns</span>:<span class="string">&quot;(fnObj = &#123; hello: () =&gt; &#x27;world&#x27; &#125;) =&gt; &#123;\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\n  // https://github.com/feross/fromentries\n  function fromEntries(iterable) &#123;\n    return [...iterable].reduce((obj, [key, val]) =&gt; &#123;\n      obj[key] = val\n      return obj\n    &#125;, &#123;&#125;)\n  &#125;\n  return (Object.fromEntries || fromEntries)(\n    Object.entries(fnObj)\n      .filter(([key, value]) =&gt; typeof value === &#x27;function&#x27;)\n      .map(([key, value]) =&gt; [key, value.toString()]) // eslint-disable-line no-eval\n  )\n&#125;&quot;</span>,<span class="attr">materializeFns</span>:<span class="string">&quot;(fnStrObj = &#123; hello: \&quot;() =&gt; &#x27;world&#x27;\&quot; &#125;) =&gt; &#123;\n  return Object.fromEntries(\n    Object.entries(fnStrObj).map(([key, value]) =&gt; &#123;\n      if (value.startsWith(&#x27;function&#x27;)) &#123;\n        // some trickery is needed to make oldschool functions work :-)\n        return [key, eval(`() =&gt; $&#123;value&#125;`)()] // eslint-disable-line no-eval\n      &#125; else &#123;\n        // arrow functions just work\n        return [key, eval(value)] // eslint-disable-line no-eval\n      &#125;\n    &#125;)\n  )\n&#125;&quot;</span>,<span class="attr">makeHandler</span>:<span class="string">&quot;() =&gt; (&#123;\n  // Used by simple `navigator` getter evasions\n  getterValue: value =&gt; (&#123;\n    apply(target, ctx, args) &#123;\n      // Let&#x27;s fetch the value first, to trigger and escalate potential errors\n      // Illegal invocations like `navigator.__proto__.vendor` will throw here\n      utils.cache.Reflect.apply(...arguments)\n      return value\n    &#125;\n  &#125;)\n&#125;)&quot;</span>,<span class="attr">arrayEquals</span>:<span class="string">&quot;(array1, array2) =&gt; &#123;\n  if (array1.length !== array2.length) &#123;\n    return false\n  &#125;\n  for (let i = 0; i &lt; array1.length; ++i) &#123;\n    if (array1[i] !== array2[i]) &#123;\n      return false\n    &#125;\n  &#125;\n  return true\n&#125;&quot;</span>,<span class="attr">memoize</span>:<span class="string">&quot;fn =&gt; &#123;\n  const cache = []\n  return function(...args) &#123;\n    if (!cache.some(c =&gt; utils.arrayEquals(c.key, args))) &#123;\n      cache.push(&#123; key: args, value: fn.apply(this, args) &#125;)\n    &#125;\n    return cache.find(c =&gt; utils.arrayEquals(c.key, args)).value\n  &#125;\n&#125;&quot;</span>&#125;,<span class="attr">_mainFunction</span>:<span class="string">&quot;(utils, &#123; fns, data &#125;) =&gt; &#123;\n        fns = utils.materializeFns(fns)\n\n        // That means we&#x27;re running headful\n        const hasPlugins = &#x27;plugins&#x27; in navigator &amp;&amp; navigator.plugins.length\n        if (hasPlugins) &#123;\n          return // nothing to do here\n        &#125;\n\n        const mimeTypes = fns.generateMimeTypeArray(utils, fns)(data.mimeTypes)\n        const plugins = fns.generatePluginArray(utils, fns)(data.plugins)\n\n        // Plugin and MimeType cross-reference each other, let&#x27;s do that now\n        // Note: We&#x27;re looping through `data.plugins` here, not the generated `plugins`\n        for (const pluginData of data.plugins) &#123;\n          pluginData.__mimeTypes.forEach((type, index) =&gt; &#123;\n            plugins[pluginData.name][index] = mimeTypes[type]\n\n            Object.defineProperty(plugins[pluginData.name], type, &#123;\n              value: mimeTypes[type],\n              writable: false,\n              enumerable: false, // Not enumerable\n              configurable: true\n            &#125;)\n            Object.defineProperty(mimeTypes[type], &#x27;enabledPlugin&#x27;, &#123;\n              value:\n                type === &#x27;application/x-pnacl&#x27;\n                  ? mimeTypes[&#x27;application/x-nacl&#x27;].enabledPlugin // these reference the same plugin, so we need to re-use the Proxy in order to avoid leaks\n                  : new Proxy(plugins[pluginData.name], &#123;&#125;), // Prevent circular references\n              writable: false,\n              enumerable: false, // Important: `JSON.stringify(navigator.plugins)`\n              configurable: true\n            &#125;)\n          &#125;)\n        &#125;\n\n        const patchNavigator = (name, value) =&gt;\n          utils.replaceProperty(Object.getPrototypeOf(navigator), name, &#123;\n            get() &#123;\n              return value\n            &#125;\n          &#125;)\n\n        patchNavigator(&#x27;mimeTypes&#x27;, mimeTypes)\n        patchNavigator(&#x27;plugins&#x27;, plugins)\n\n        // All done\n      &#125;&quot;</span>,<span class="attr">_args</span>:[&#123;<span class="attr">fns</span>:&#123;<span class="attr">generateMimeTypeArray</span>:<span class="string">&quot;(utils, fns) =&gt; mimeTypesData =&gt; &#123;\n  return fns.generateMagicArray(utils, fns)(\n    mimeTypesData,\n    MimeTypeArray.prototype,\n    MimeType.prototype,\n    &#x27;type&#x27;\n  )\n&#125;&quot;</span>,<span class="attr">generatePluginArray</span>:<span class="string">&quot;(utils, fns) =&gt; pluginsData =&gt; &#123;\n  return fns.generateMagicArray(utils, fns)(\n    pluginsData,\n    PluginArray.prototype,\n    Plugin.prototype,\n    &#x27;name&#x27;\n  )\n&#125;&quot;</span>,<span class="attr">generateMagicArray</span>:<span class="string">&quot;(utils, fns) =&gt;\n  function(\n    dataArray = [],\n    proto = MimeTypeArray.prototype,\n    itemProto = MimeType.prototype,\n    itemMainProp = &#x27;type&#x27;\n  ) &#123;\n    // Quick helper to set props with the same descriptors vanilla is using\n    const defineProp = (obj, prop, value) =&gt;\n      Object.defineProperty(obj, prop, &#123;\n        value,\n        writable: false,\n        enumerable: false, // Important for mimeTypes &amp; plugins: `JSON.stringify(navigator.mimeTypes)`\n        configurable: true\n      &#125;)\n\n    // Loop over our fake data and construct items\n    const makeItem = data =&gt; &#123;\n      const item = &#123;&#125;\n      for (const prop of Object.keys(data)) &#123;\n        if (prop.startsWith(&#x27;__&#x27;)) &#123;\n          continue\n        &#125;\n        defineProp(item, prop, data[prop])\n      &#125;\n      return patchItem(item, data)\n    &#125;\n\n    const patchItem = (item, data) =&gt; &#123;\n      let descriptor = Object.getOwnPropertyDescriptors(item)\n\n      // Special case: Plugins have a magic length property which is not enumerable\n      // e.g. `navigator.plugins[i].length` should always be the length of the assigned mimeTypes\n      if (itemProto === Plugin.prototype) &#123;\n        descriptor = &#123;\n          ...descriptor,\n          length: &#123;\n            value: data.__mimeTypes.length,\n            writable: false,\n            enumerable: false,\n            configurable: true // Important to be able to use the ownKeys trap in a Proxy to strip `length`\n          &#125;\n        &#125;\n      &#125;\n\n      // We need to spoof a specific `MimeType` or `Plugin` object\n      const obj = Object.create(itemProto, descriptor)\n\n      // Virtually all property keys are not enumerable in vanilla\n      const blacklist = [...Object.keys(data), &#x27;length&#x27;, &#x27;enabledPlugin&#x27;]\n      return new Proxy(obj, &#123;\n        ownKeys(target) &#123;\n          return Reflect.ownKeys(target).filter(k =&gt; !blacklist.includes(k))\n        &#125;,\n        getOwnPropertyDescriptor(target, prop) &#123;\n          if (blacklist.includes(prop)) &#123;\n            return undefined\n          &#125;\n          return Reflect.getOwnPropertyDescriptor(target, prop)\n        &#125;\n      &#125;)\n    &#125;\n\n    const magicArray = []\n\n    // Loop through our fake data and use that to create convincing entities\n    dataArray.forEach(data =&gt; &#123;\n      magicArray.push(makeItem(data))\n    &#125;)\n\n    // Add direct property access  based on types (e.g. `obj[&#x27;application/pdf&#x27;]`) afterwards\n    magicArray.forEach(entry =&gt; &#123;\n      defineProp(magicArray, entry[itemMainProp], entry)\n    &#125;)\n\n    // This is the best way to fake the type to make sure this is false: `Array.isArray(navigator.mimeTypes)`\n    const magicArrayObj = Object.create(proto, &#123;\n      ...Object.getOwnPropertyDescriptors(magicArray),\n\n      // There&#x27;s one ugly quirk we unfortunately need to take care of:\n      // The `MimeTypeArray` prototype has an enumerable `length` property,\n      // but headful Chrome will still skip it when running `Object.getOwnPropertyNames(navigator.mimeTypes)`.\n      // To strip it we need to make it first `configurable` and can then overlay a Proxy with an `ownKeys` trap.\n      length: &#123;\n        value: magicArray.length,\n        writable: false,\n        enumerable: false,\n        configurable: true // Important to be able to use the ownKeys trap in a Proxy to strip `length`\n      &#125;\n    &#125;)\n\n    // Generate our functional function mocks :-)\n    const functionMocks = fns.generateFunctionMocks(utils)(\n      proto,\n      itemMainProp,\n      magicArray\n    )\n\n    // We need to overlay our custom object with a JS Proxy\n    const magicArrayObjProxy = new Proxy(magicArrayObj, &#123;\n      get(target, key = &#x27;&#x27;) &#123;\n        // Redirect function calls to our custom proxied versions mocking the vanilla behavior\n        if (key === &#x27;item&#x27;) &#123;\n          return functionMocks.item\n        &#125;\n        if (key === &#x27;namedItem&#x27;) &#123;\n          return functionMocks.namedItem\n        &#125;\n        if (proto === PluginArray.prototype &amp;&amp; key === &#x27;refresh&#x27;) &#123;\n          return functionMocks.refresh\n        &#125;\n        // Everything else can pass through as normal\n        return utils.cache.Reflect.get(...arguments)\n      &#125;,\n      ownKeys(target) &#123;\n        // There are a couple of quirks where the original property demonstrates \&quot;magical\&quot; behavior that makes no sense\n        // This can be witnessed when calling `Object.getOwnPropertyNames(navigator.mimeTypes)` and the absense of `length`\n        // My guess is that it has to do with the recent change of not allowing data enumeration and this being implemented weirdly\n        // For that reason we just completely fake the available property names based on our data to match what regular Chrome is doing\n        // Specific issues when not patching this: `length` property is available, direct `types` props (e.g. `obj[&#x27;application/pdf&#x27;]`) are missing\n        const keys = []\n        const typeProps = magicArray.map(mt =&gt; mt[itemMainProp])\n        typeProps.forEach((_, i) =&gt; keys.push(`$&#123;i&#125;`))\n        typeProps.forEach(propName =&gt; keys.push(propName))\n        return keys\n      &#125;,\n      getOwnPropertyDescriptor(target, prop) &#123;\n        if (prop === &#x27;length&#x27;) &#123;\n          return undefined\n        &#125;\n        return Reflect.getOwnPropertyDescriptor(target, prop)\n      &#125;\n    &#125;)\n\n    return magicArrayObjProxy\n  &#125;&quot;</span>,<span class="attr">generateFunctionMocks</span>:<span class="string">&quot;utils =&gt; (\n  proto,\n  itemMainProp,\n  dataArray\n) =&gt; (&#123;\n  /** Returns the MimeType object with the specified index. */\n  item: utils.createProxy(proto.item, &#123;\n    apply(target, ctx, args) &#123;\n      if (!args.length) &#123;\n        throw new TypeError(\n          `Failed to execute &#x27;item&#x27; on &#x27;$&#123;\n            proto[Symbol.toStringTag]\n          &#125;&#x27;: 1 argument required, but only 0 present.`\n        )\n      &#125;\n      // Special behavior alert:\n      // - Vanilla tries to cast strings to Numbers (only integers!) and use them as property index lookup\n      // - If anything else than an integer (including as string) is provided it will return the first entry\n      const isInteger = args[0] &amp;&amp; Number.isInteger(Number(args[0])) // Cast potential string to number first, then check for integer\n      // Note: Vanilla never returns `undefined`\n      return (isInteger ? dataArray[Number(args[0])] : dataArray[0]) || null\n    &#125;\n  &#125;),\n  /** Returns the MimeType object with the specified name. */\n  namedItem: utils.createProxy(proto.namedItem, &#123;\n    apply(target, ctx, args) &#123;\n      if (!args.length) &#123;\n        throw new TypeError(\n          `Failed to execute &#x27;namedItem&#x27; on &#x27;$&#123;\n            proto[Symbol.toStringTag]\n          &#125;&#x27;: 1 argument required, but only 0 present.`\n        )\n      &#125;\n      return dataArray.find(mt =&gt; mt[itemMainProp] === args[0]) || null // Not `undefined`!\n    &#125;\n  &#125;),\n  /** Does nothing and shall return nothing */\n  refresh: proto.refresh\n    ? utils.createProxy(proto.refresh, &#123;\n        apply(target, ctx, args) &#123;\n          return undefined\n        &#125;\n      &#125;)\n    : undefined\n&#125;)&quot;</span>&#125;,<span class="attr">data</span>:&#123;<span class="attr">mimeTypes</span>:[&#123;<span class="attr">type</span>:<span class="string">&quot;application/pdf&quot;</span>,<span class="attr">suffixes</span>:<span class="string">&quot;pdf&quot;</span>,<span class="attr">description</span>:<span class="string">&quot;&quot;</span>,<span class="attr">__pluginName</span>:<span class="string">&quot;Chrome PDF Viewer&quot;</span>&#125;,&#123;<span class="attr">type</span>:<span class="string">&quot;application/x-google-chrome-pdf&quot;</span>,<span class="attr">suffixes</span>:<span class="string">&quot;pdf&quot;</span>,<span class="attr">description</span>:<span class="string">&quot;Portable Document Format&quot;</span>,<span class="attr">__pluginName</span>:<span class="string">&quot;Chrome PDF Plugin&quot;</span>&#125;,&#123;<span class="attr">type</span>:<span class="string">&quot;application/x-nacl&quot;</span>,<span class="attr">suffixes</span>:<span class="string">&quot;&quot;</span>,<span class="attr">description</span>:<span class="string">&quot;Native Client Executable&quot;</span>,<span class="attr">__pluginName</span>:<span class="string">&quot;Native Client&quot;</span>&#125;,&#123;<span class="attr">type</span>:<span class="string">&quot;application/x-pnacl&quot;</span>,<span class="attr">suffixes</span>:<span class="string">&quot;&quot;</span>,<span class="attr">description</span>:<span class="string">&quot;Portable Native Client Executable&quot;</span>,<span class="attr">__pluginName</span>:<span class="string">&quot;Native Client&quot;</span>&#125;],<span class="attr">plugins</span>:[&#123;<span class="attr">name</span>:<span class="string">&quot;Chrome PDF Plugin&quot;</span>,<span class="attr">filename</span>:<span class="string">&quot;internal-pdf-viewer&quot;</span>,<span class="attr">description</span>:<span class="string">&quot;Portable Document Format&quot;</span>,<span class="attr">__mimeTypes</span>:[<span class="string">&quot;application/x-google-chrome-pdf&quot;</span>]&#125;,&#123;<span class="attr">name</span>:<span class="string">&quot;Chrome PDF Viewer&quot;</span>,<span class="attr">filename</span>:<span class="string">&quot;mhjfbmdgcfjbbpaeojofohoefgiehjai&quot;</span>,<span class="attr">description</span>:<span class="string">&quot;&quot;</span>,<span class="attr">__mimeTypes</span>:[<span class="string">&quot;application/pdf&quot;</span>]&#125;,&#123;<span class="attr">name</span>:<span class="string">&quot;Native Client&quot;</span>,<span class="attr">filename</span>:<span class="string">&quot;internal-nacl-plugin&quot;</span>,<span class="attr">description</span>:<span class="string">&quot;&quot;</span>,<span class="attr">__mimeTypes</span>:[<span class="string">&quot;application/x-nacl&quot;</span>,<span class="string">&quot;application/x-pnacl&quot;</span>]&#125;]&#125;&#125;]&#125;),!<span class="number">1</span>===navigator.<span class="property">webdriver</span>||<span class="keyword">void</span> <span class="number">0</span>===navigator.<span class="property">webdriver</span>||<span class="keyword">delete</span> <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(navigator).<span class="property">webdriver</span>,(<span class="function">(<span class="params">&#123;_utilsFns:_utilsFns,_mainFunction:_mainFunction,_args:_args&#125;</span>)=&gt;</span>&#123;<span class="keyword">const</span> utils=<span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(_utilsFns).<span class="title function_">map</span>((<span class="function">(<span class="params">[key,value]</span>)=&gt;</span>[key,<span class="built_in">eval</span>(value)])));utils.<span class="title function_">init</span>(),<span class="built_in">eval</span>(_mainFunction)(utils,..._args)&#125;)(&#123;<span class="attr">_utilsFns</span>:&#123;<span class="attr">init</span>:<span class="string">&quot;() =&gt; &#123;\n  utils.preloadCache()\n&#125;&quot;</span>,<span class="attr">stripProxyFromErrors</span>:<span class="string">&quot;(handler = &#123;&#125;) =&gt; &#123;\n  const newHandler = &#123;\n    setPrototypeOf: function (target, proto) &#123;\n      if (proto === null)\n        throw new TypeError(&#x27;Cannot convert object to primitive value&#x27;)\n      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) &#123;\n        throw new TypeError(&#x27;Cyclic __proto__ value&#x27;)\n      &#125;\n      return Reflect.setPrototypeOf(target, proto)\n    &#125;\n  &#125;\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\n  const traps = Object.getOwnPropertyNames(handler)\n  traps.forEach(trap =&gt; &#123;\n    newHandler[trap] = function () &#123;\n      try &#123;\n        // Forward the call to the defined proxy handler\n        return handler[trap].apply(this, arguments || [])\n      &#125; catch (err) &#123;\n        // Stack traces differ per browser, we only support chromium based ones currently\n        if (!err || !err.stack || !err.stack.includes(`at `)) &#123;\n          throw err\n        &#125;\n\n        // When something throws within one of our traps the Proxy will show up in error stacks\n        // An earlier implementation of this code would simply strip lines with a blacklist,\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\n        // We try to use a known \&quot;anchor\&quot; line for that and strip it with everything above it.\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\n\n        const stripWithBlacklist = (stack, stripFirstLine = true) =&gt; &#123;\n          const blacklist = [\n            `at Reflect.$&#123;trap&#125; `, // e.g. Reflect.get or Reflect.apply\n            `at Object.$&#123;trap&#125; `, // e.g. Object.get or Object.apply\n            `at Object.newHandler.&lt;computed&gt; [as $&#123;trap&#125;] ` // caused by this very wrapper :-)\n          ]\n          return (\n            err.stack\n              .split(&#x27;\\n&#x27;)\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\n              .filter((line, index) =&gt; !(index === 1 &amp;&amp; stripFirstLine))\n              // Check if the line starts with one of our blacklisted strings\n              .filter(line =&gt; !blacklist.some(bl =&gt; line.trim().startsWith(bl)))\n              .join(&#x27;\\n&#x27;)\n          )\n        &#125;\n\n        const stripWithAnchor = (stack, anchor) =&gt; &#123;\n          const stackArr = stack.split(&#x27;\\n&#x27;)\n          anchor = anchor || `at Object.newHandler.&lt;computed&gt; [as $&#123;trap&#125;] ` // Known first Proxy line in chromium\n          const anchorIndex = stackArr.findIndex(line =&gt;\n            line.trim().startsWith(anchor)\n          )\n          if (anchorIndex === -1) &#123;\n            return false // 404, anchor not found\n          &#125;\n          // Strip everything from the top until we reach the anchor line\n          // Note: We&#x27;re keeping the 1st line (zero index) as it&#x27;s unrelated (e.g. `TypeError`)\n          stackArr.splice(1, anchorIndex)\n          return stackArr.join(&#x27;\\n&#x27;)\n        &#125;\n\n        // Special cases due to our nested toString proxies\n        err.stack = err.stack.replace(\n          &#x27;at Object.toString (&#x27;,\n          &#x27;at Function.toString (&#x27;\n        )\n        if ((err.stack || &#x27;&#x27;).includes(&#x27;at Function.toString (&#x27;)) &#123;\n          err.stack = stripWithBlacklist(err.stack, false)\n          throw err\n        &#125;\n\n        // Try using the anchor method, fallback to blacklist if necessary\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\n\n        throw err // Re-throw our now sanitized error\n      &#125;\n    &#125;\n  &#125;)\n  return newHandler\n&#125;&quot;</span>,<span class="attr">stripErrorWithAnchor</span>:<span class="string">&quot;(err, anchor) =&gt; &#123;\n  const stackArr = err.stack.split(&#x27;\\n&#x27;)\n  const anchorIndex = stackArr.findIndex(line =&gt; line.trim().startsWith(anchor))\n  if (anchorIndex === -1) &#123;\n    return err // 404, anchor not found\n  &#125;\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\n  // Note: We&#x27;re keeping the 1st line (zero index) as it&#x27;s unrelated (e.g. `TypeError`)\n  stackArr.splice(1, anchorIndex)\n  err.stack = stackArr.join(&#x27;\\n&#x27;)\n  return err\n&#125;&quot;</span>,<span class="attr">replaceProperty</span>:<span class="string">&quot;(obj, propName, descriptorOverrides = &#123;&#125;) =&gt; &#123;\n  return Object.defineProperty(obj, propName, &#123;\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || &#123;&#125;),\n    // Add our overrides (e.g. value, get())\n    ...descriptorOverrides\n  &#125;)\n&#125;&quot;</span>,<span class="attr">preloadCache</span>:<span class="string">&quot;() =&gt; &#123;\n  if (utils.cache) &#123;\n    return\n  &#125;\n  utils.cache = &#123;\n    // Used in our proxies\n    Reflect: &#123;\n      get: Reflect.get.bind(Reflect),\n      apply: Reflect.apply.bind(Reflect)\n    &#125;,\n    // Used in `makeNativeString`\n    nativeToStringStr: Function.toString + &#x27;&#x27; // =&gt; `function toString() &#123; [native code] &#125;`\n  &#125;\n&#125;&quot;</span>,<span class="attr">makeNativeString</span>:<span class="string">&quot;(name = &#x27;&#x27;) =&gt; &#123;\n  return utils.cache.nativeToStringStr.replace(&#x27;toString&#x27;, name || &#x27;&#x27;)\n&#125;&quot;</span>,<span class="attr">patchToString</span>:<span class="string">&quot;(obj, str = &#x27;&#x27;) =&gt; &#123;\n  const handler = &#123;\n    apply: function (target, ctx) &#123;\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \&quot;\&quot;`\n      if (ctx === Function.prototype.toString) &#123;\n        return utils.makeNativeString(&#x27;toString&#x27;)\n      &#125;\n      // `toString` targeted at our proxied Object detected\n      if (ctx === obj) &#123;\n        // We either return the optional string verbatim or derive the most desired result automatically\n        return str || utils.makeNativeString(obj.name)\n      &#125;\n      // Check if the toString protype of the context is the same as the global prototype,\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\n      const hasSameProto = Object.getPrototypeOf(\n        Function.prototype.toString\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\n      if (!hasSameProto) &#123;\n        // Pass the call on to the local Function.prototype.toString instead\n        return ctx.toString()\n      &#125;\n      return target.call(ctx)\n    &#125;\n  &#125;\n\n  const toStringProxy = new Proxy(\n    Function.prototype.toString,\n    utils.stripProxyFromErrors(handler)\n  )\n  utils.replaceProperty(Function.prototype, &#x27;toString&#x27;, &#123;\n    value: toStringProxy\n  &#125;)\n&#125;&quot;</span>,<span class="attr">patchToStringNested</span>:<span class="string">&quot;(obj = &#123;&#125;) =&gt; &#123;\n  return utils.execRecursively(obj, [&#x27;function&#x27;], utils.patchToString)\n&#125;&quot;</span>,<span class="attr">redirectToString</span>:<span class="string">&quot;(proxyObj, originalObj) =&gt; &#123;\n  const handler = &#123;\n    apply: function (target, ctx) &#123;\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \&quot;\&quot;`\n      if (ctx === Function.prototype.toString) &#123;\n        return utils.makeNativeString(&#x27;toString&#x27;)\n      &#125;\n\n      // `toString` targeted at our proxied Object detected\n      if (ctx === proxyObj) &#123;\n        const fallback = () =&gt;\n          originalObj &amp;&amp; originalObj.name\n            ? utils.makeNativeString(originalObj.name)\n            : utils.makeNativeString(proxyObj.name)\n\n        // Return the toString representation of our original object if possible\n        return originalObj + &#x27;&#x27; || fallback()\n      &#125;\n\n      if (typeof ctx === &#x27;undefined&#x27; || ctx === null) &#123;\n        return target.call(ctx)\n      &#125;\n\n      // Check if the toString protype of the context is the same as the global prototype,\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\n      const hasSameProto = Object.getPrototypeOf(\n        Function.prototype.toString\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\n      if (!hasSameProto) &#123;\n        // Pass the call on to the local Function.prototype.toString instead\n        return ctx.toString()\n      &#125;\n\n      return target.call(ctx)\n    &#125;\n  &#125;\n\n  const toStringProxy = new Proxy(\n    Function.prototype.toString,\n    utils.stripProxyFromErrors(handler)\n  )\n  utils.replaceProperty(Function.prototype, &#x27;toString&#x27;, &#123;\n    value: toStringProxy\n  &#125;)\n&#125;&quot;</span>,<span class="attr">replaceWithProxy</span>:<span class="string">&quot;(obj, propName, handler) =&gt; &#123;\n  const originalObj = obj[propName]\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, &#123; value: proxyObj &#125;)\n  utils.redirectToString(proxyObj, originalObj)\n\n  return true\n&#125;&quot;</span>,<span class="attr">replaceGetterWithProxy</span>:<span class="string">&quot;(obj, propName, handler) =&gt; &#123;\n  const fn = Object.getOwnPropertyDescriptor(obj, propName).get\n  const fnStr = fn.toString() // special getter function string\n  const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, &#123; get: proxyObj &#125;)\n  utils.patchToString(proxyObj, fnStr)\n\n  return true\n&#125;&quot;</span>,<span class="attr">replaceGetterSetter</span>:<span class="string">&quot;(obj, propName, handlerGetterSetter) =&gt; &#123;\n  const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)\n  const handler = &#123; ...ownPropertyDescriptor &#125;\n\n  if (handlerGetterSetter.get !== undefined) &#123;\n    const nativeFn = ownPropertyDescriptor.get\n    handler.get = function() &#123;\n      return handlerGetterSetter.get.call(this, nativeFn.bind(this))\n    &#125;\n    utils.redirectToString(handler.get, nativeFn)\n  &#125;\n\n  if (handlerGetterSetter.set !== undefined) &#123;\n    const nativeFn = ownPropertyDescriptor.set\n    handler.set = function(newValue) &#123;\n      handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this))\n    &#125;\n    utils.redirectToString(handler.set, nativeFn)\n  &#125;\n\n  Object.defineProperty(obj, propName, handler)\n&#125;&quot;</span>,<span class="attr">mockWithProxy</span>:<span class="string">&quot;(obj, propName, pseudoTarget, handler) =&gt; &#123;\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, &#123; value: proxyObj &#125;)\n  utils.patchToString(proxyObj)\n\n  return true\n&#125;&quot;</span>,<span class="attr">createProxy</span>:<span class="string">&quot;(pseudoTarget, handler) =&gt; &#123;\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\n  utils.patchToString(proxyObj)\n\n  return proxyObj\n&#125;&quot;</span>,<span class="attr">splitObjPath</span>:<span class="string">&quot;objPath =&gt; (&#123;\n  // Remove last dot entry (property) ==&gt; `HTMLMediaElement.prototype`\n  objName: objPath.split(&#x27;.&#x27;).slice(0, -1).join(&#x27;.&#x27;),\n  // Extract last dot entry ==&gt; `canPlayType`\n  propName: objPath.split(&#x27;.&#x27;).slice(-1)[0]\n&#125;)&quot;</span>,<span class="attr">replaceObjPathWithProxy</span>:<span class="string">&quot;(objPath, handler) =&gt; &#123;\n  const &#123; objName, propName &#125; = utils.splitObjPath(objPath)\n  const obj = eval(objName) // eslint-disable-line no-eval\n  return utils.replaceWithProxy(obj, propName, handler)\n&#125;&quot;</span>,<span class="attr">execRecursively</span>:<span class="string">&quot;(obj = &#123;&#125;, typeFilter = [], fn) =&gt; &#123;\n  function recurse(obj) &#123;\n    for (const key in obj) &#123;\n      if (obj[key] === undefined) &#123;\n        continue\n      &#125;\n      if (obj[key] &amp;&amp; typeof obj[key] === &#x27;object&#x27;) &#123;\n        recurse(obj[key])\n      &#125; else &#123;\n        if (obj[key] &amp;&amp; typeFilter.includes(typeof obj[key])) &#123;\n          fn.call(this, obj[key])\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n  recurse(obj)\n  return obj\n&#125;&quot;</span>,<span class="attr">stringifyFns</span>:<span class="string">&quot;(fnObj = &#123; hello: () =&gt; &#x27;world&#x27; &#125;) =&gt; &#123;\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\n  // https://github.com/feross/fromentries\n  function fromEntries(iterable) &#123;\n    return [...iterable].reduce((obj, [key, val]) =&gt; &#123;\n      obj[key] = val\n      return obj\n    &#125;, &#123;&#125;)\n  &#125;\n  return (Object.fromEntries || fromEntries)(\n    Object.entries(fnObj)\n      .filter(([key, value]) =&gt; typeof value === &#x27;function&#x27;)\n      .map(([key, value]) =&gt; [key, value.toString()]) // eslint-disable-line no-eval\n  )\n&#125;&quot;</span>,<span class="attr">materializeFns</span>:<span class="string">&quot;(fnStrObj = &#123; hello: \&quot;() =&gt; &#x27;world&#x27;\&quot; &#125;) =&gt; &#123;\n  return Object.fromEntries(\n    Object.entries(fnStrObj).map(([key, value]) =&gt; &#123;\n      if (value.startsWith(&#x27;function&#x27;)) &#123;\n        // some trickery is needed to make oldschool functions work :-)\n        return [key, eval(`() =&gt; $&#123;value&#125;`)()] // eslint-disable-line no-eval\n      &#125; else &#123;\n        // arrow functions just work\n        return [key, eval(value)] // eslint-disable-line no-eval\n      &#125;\n    &#125;)\n  )\n&#125;&quot;</span>,<span class="attr">makeHandler</span>:<span class="string">&quot;() =&gt; (&#123;\n  // Used by simple `navigator` getter evasions\n  getterValue: value =&gt; (&#123;\n    apply(target, ctx, args) &#123;\n      // Let&#x27;s fetch the value first, to trigger and escalate potential errors\n      // Illegal invocations like `navigator.__proto__.vendor` will throw here\n      utils.cache.Reflect.apply(...arguments)\n      return value\n    &#125;\n  &#125;)\n&#125;)&quot;</span>,<span class="attr">arrayEquals</span>:<span class="string">&quot;(array1, array2) =&gt; &#123;\n  if (array1.length !== array2.length) &#123;\n    return false\n  &#125;\n  for (let i = 0; i &lt; array1.length; ++i) &#123;\n    if (array1[i] !== array2[i]) &#123;\n      return false\n    &#125;\n  &#125;\n  return true\n&#125;&quot;</span>,<span class="attr">memoize</span>:<span class="string">&quot;fn =&gt; &#123;\n  const cache = []\n  return function(...args) &#123;\n    if (!cache.some(c =&gt; utils.arrayEquals(c.key, args))) &#123;\n      cache.push(&#123; key: args, value: fn.apply(this, args) &#125;)\n    &#125;\n    return cache.find(c =&gt; utils.arrayEquals(c.key, args)).value\n  &#125;\n&#125;&quot;</span>&#125;,<span class="attr">_mainFunction</span>:<span class="string">&quot;(utils, opts) =&gt; &#123;\n      const getParameterProxyHandler = &#123;\n        apply: function(target, ctx, args) &#123;\n          const param = (args || [])[0]\n          const result = utils.cache.Reflect.apply(target, ctx, args)\n          // UNMASKED_VENDOR_WEBGL\n          if (param === 37445) &#123;\n            return opts.vendor || &#x27;Intel Inc.&#x27; // default in headless: Google Inc.\n          &#125;\n          // UNMASKED_RENDERER_WEBGL\n          if (param === 37446) &#123;\n            return opts.renderer || &#x27;Intel Iris OpenGL Engine&#x27; // default in headless: Google SwiftShader\n          &#125;\n          return result\n        &#125;\n      &#125;\n\n      // There&#x27;s more than one WebGL rendering context\n      // https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext#Browser_compatibility\n      // To find out the original values here: Object.getOwnPropertyDescriptors(WebGLRenderingContext.prototype.getParameter)\n      const addProxy = (obj, propName) =&gt; &#123;\n        utils.replaceWithProxy(obj, propName, getParameterProxyHandler)\n      &#125;\n      // For whatever weird reason loops don&#x27;t play nice with Object.defineProperty, here&#x27;s the next best thing:\n      addProxy(WebGLRenderingContext.prototype, &#x27;getParameter&#x27;)\n      addProxy(WebGL2RenderingContext.prototype, &#x27;getParameter&#x27;)\n    &#125;&quot;</span>,<span class="attr">_args</span>:[&#123;&#125;]&#125;),(<span class="function">()=&gt;</span>&#123;<span class="keyword">try</span>&#123;<span class="keyword">if</span>(<span class="variable language_">window</span>.<span class="property">outerWidth</span>&amp;&amp;<span class="variable language_">window</span>.<span class="property">outerHeight</span>)<span class="keyword">return</span>;<span class="keyword">const</span> n=<span class="number">85</span>;<span class="variable language_">window</span>.<span class="property">outerWidth</span>=<span class="variable language_">window</span>.<span class="property">innerWidth</span>,<span class="variable language_">window</span>.<span class="property">outerHeight</span>=<span class="variable language_">window</span>.<span class="property">innerHeight</span>+n&#125;<span class="keyword">catch</span>(n)&#123;&#125;&#125;)(),(<span class="function">(<span class="params">&#123;_utilsFns:_utilsFns,_mainFunction:_mainFunction,_args:_args&#125;</span>)=&gt;</span>&#123;<span class="keyword">const</span> utils=<span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(_utilsFns).<span class="title function_">map</span>((<span class="function">(<span class="params">[key,value]</span>)=&gt;</span>[key,<span class="built_in">eval</span>(value)])));utils.<span class="title function_">init</span>(),<span class="built_in">eval</span>(_mainFunction)(utils,..._args)&#125;)(&#123;<span class="attr">_utilsFns</span>:&#123;<span class="attr">init</span>:<span class="string">&quot;() =&gt; &#123;\n  utils.preloadCache()\n&#125;&quot;</span>,<span class="attr">stripProxyFromErrors</span>:<span class="string">&quot;(handler = &#123;&#125;) =&gt; &#123;\n  const newHandler = &#123;\n    setPrototypeOf: function (target, proto) &#123;\n      if (proto === null)\n        throw new TypeError(&#x27;Cannot convert object to primitive value&#x27;)\n      if (Object.getPrototypeOf(target) === Object.getPrototypeOf(proto)) &#123;\n        throw new TypeError(&#x27;Cyclic __proto__ value&#x27;)\n      &#125;\n      return Reflect.setPrototypeOf(target, proto)\n    &#125;\n  &#125;\n  // We wrap each trap in the handler in a try/catch and modify the error stack if they throw\n  const traps = Object.getOwnPropertyNames(handler)\n  traps.forEach(trap =&gt; &#123;\n    newHandler[trap] = function () &#123;\n      try &#123;\n        // Forward the call to the defined proxy handler\n        return handler[trap].apply(this, arguments || [])\n      &#125; catch (err) &#123;\n        // Stack traces differ per browser, we only support chromium based ones currently\n        if (!err || !err.stack || !err.stack.includes(`at `)) &#123;\n          throw err\n        &#125;\n\n        // When something throws within one of our traps the Proxy will show up in error stacks\n        // An earlier implementation of this code would simply strip lines with a blacklist,\n        // but it makes sense to be more surgical here and only remove lines related to our Proxy.\n        // We try to use a known \&quot;anchor\&quot; line for that and strip it with everything above it.\n        // If the anchor line cannot be found for some reason we fall back to our blacklist approach.\n\n        const stripWithBlacklist = (stack, stripFirstLine = true) =&gt; &#123;\n          const blacklist = [\n            `at Reflect.$&#123;trap&#125; `, // e.g. Reflect.get or Reflect.apply\n            `at Object.$&#123;trap&#125; `, // e.g. Object.get or Object.apply\n            `at Object.newHandler.&lt;computed&gt; [as $&#123;trap&#125;] ` // caused by this very wrapper :-)\n          ]\n          return (\n            err.stack\n              .split(&#x27;\\n&#x27;)\n              // Always remove the first (file) line in the stack (guaranteed to be our proxy)\n              .filter((line, index) =&gt; !(index === 1 &amp;&amp; stripFirstLine))\n              // Check if the line starts with one of our blacklisted strings\n              .filter(line =&gt; !blacklist.some(bl =&gt; line.trim().startsWith(bl)))\n              .join(&#x27;\\n&#x27;)\n          )\n        &#125;\n\n        const stripWithAnchor = (stack, anchor) =&gt; &#123;\n          const stackArr = stack.split(&#x27;\\n&#x27;)\n          anchor = anchor || `at Object.newHandler.&lt;computed&gt; [as $&#123;trap&#125;] ` // Known first Proxy line in chromium\n          const anchorIndex = stackArr.findIndex(line =&gt;\n            line.trim().startsWith(anchor)\n          )\n          if (anchorIndex === -1) &#123;\n            return false // 404, anchor not found\n          &#125;\n          // Strip everything from the top until we reach the anchor line\n          // Note: We&#x27;re keeping the 1st line (zero index) as it&#x27;s unrelated (e.g. `TypeError`)\n          stackArr.splice(1, anchorIndex)\n          return stackArr.join(&#x27;\\n&#x27;)\n        &#125;\n\n        // Special cases due to our nested toString proxies\n        err.stack = err.stack.replace(\n          &#x27;at Object.toString (&#x27;,\n          &#x27;at Function.toString (&#x27;\n        )\n        if ((err.stack || &#x27;&#x27;).includes(&#x27;at Function.toString (&#x27;)) &#123;\n          err.stack = stripWithBlacklist(err.stack, false)\n          throw err\n        &#125;\n\n        // Try using the anchor method, fallback to blacklist if necessary\n        err.stack = stripWithAnchor(err.stack) || stripWithBlacklist(err.stack)\n\n        throw err // Re-throw our now sanitized error\n      &#125;\n    &#125;\n  &#125;)\n  return newHandler\n&#125;&quot;</span>,<span class="attr">stripErrorWithAnchor</span>:<span class="string">&quot;(err, anchor) =&gt; &#123;\n  const stackArr = err.stack.split(&#x27;\\n&#x27;)\n  const anchorIndex = stackArr.findIndex(line =&gt; line.trim().startsWith(anchor))\n  if (anchorIndex === -1) &#123;\n    return err // 404, anchor not found\n  &#125;\n  // Strip everything from the top until we reach the anchor line (remove anchor line as well)\n  // Note: We&#x27;re keeping the 1st line (zero index) as it&#x27;s unrelated (e.g. `TypeError`)\n  stackArr.splice(1, anchorIndex)\n  err.stack = stackArr.join(&#x27;\\n&#x27;)\n  return err\n&#125;&quot;</span>,<span class="attr">replaceProperty</span>:<span class="string">&quot;(obj, propName, descriptorOverrides = &#123;&#125;) =&gt; &#123;\n  return Object.defineProperty(obj, propName, &#123;\n    // Copy over the existing descriptors (writable, enumerable, configurable, etc)\n    ...(Object.getOwnPropertyDescriptor(obj, propName) || &#123;&#125;),\n    // Add our overrides (e.g. value, get())\n    ...descriptorOverrides\n  &#125;)\n&#125;&quot;</span>,<span class="attr">preloadCache</span>:<span class="string">&quot;() =&gt; &#123;\n  if (utils.cache) &#123;\n    return\n  &#125;\n  utils.cache = &#123;\n    // Used in our proxies\n    Reflect: &#123;\n      get: Reflect.get.bind(Reflect),\n      apply: Reflect.apply.bind(Reflect)\n    &#125;,\n    // Used in `makeNativeString`\n    nativeToStringStr: Function.toString + &#x27;&#x27; // =&gt; `function toString() &#123; [native code] &#125;`\n  &#125;\n&#125;&quot;</span>,<span class="attr">makeNativeString</span>:<span class="string">&quot;(name = &#x27;&#x27;) =&gt; &#123;\n  return utils.cache.nativeToStringStr.replace(&#x27;toString&#x27;, name || &#x27;&#x27;)\n&#125;&quot;</span>,<span class="attr">patchToString</span>:<span class="string">&quot;(obj, str = &#x27;&#x27;) =&gt; &#123;\n  const handler = &#123;\n    apply: function (target, ctx) &#123;\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \&quot;\&quot;`\n      if (ctx === Function.prototype.toString) &#123;\n        return utils.makeNativeString(&#x27;toString&#x27;)\n      &#125;\n      // `toString` targeted at our proxied Object detected\n      if (ctx === obj) &#123;\n        // We either return the optional string verbatim or derive the most desired result automatically\n        return str || utils.makeNativeString(obj.name)\n      &#125;\n      // Check if the toString protype of the context is the same as the global prototype,\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\n      const hasSameProto = Object.getPrototypeOf(\n        Function.prototype.toString\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\n      if (!hasSameProto) &#123;\n        // Pass the call on to the local Function.prototype.toString instead\n        return ctx.toString()\n      &#125;\n      return target.call(ctx)\n    &#125;\n  &#125;\n\n  const toStringProxy = new Proxy(\n    Function.prototype.toString,\n    utils.stripProxyFromErrors(handler)\n  )\n  utils.replaceProperty(Function.prototype, &#x27;toString&#x27;, &#123;\n    value: toStringProxy\n  &#125;)\n&#125;&quot;</span>,<span class="attr">patchToStringNested</span>:<span class="string">&quot;(obj = &#123;&#125;) =&gt; &#123;\n  return utils.execRecursively(obj, [&#x27;function&#x27;], utils.patchToString)\n&#125;&quot;</span>,<span class="attr">redirectToString</span>:<span class="string">&quot;(proxyObj, originalObj) =&gt; &#123;\n  const handler = &#123;\n    apply: function (target, ctx) &#123;\n      // This fixes e.g. `HTMLMediaElement.prototype.canPlayType.toString + \&quot;\&quot;`\n      if (ctx === Function.prototype.toString) &#123;\n        return utils.makeNativeString(&#x27;toString&#x27;)\n      &#125;\n\n      // `toString` targeted at our proxied Object detected\n      if (ctx === proxyObj) &#123;\n        const fallback = () =&gt;\n          originalObj &amp;&amp; originalObj.name\n            ? utils.makeNativeString(originalObj.name)\n            : utils.makeNativeString(proxyObj.name)\n\n        // Return the toString representation of our original object if possible\n        return originalObj + &#x27;&#x27; || fallback()\n      &#125;\n\n      if (typeof ctx === &#x27;undefined&#x27; || ctx === null) &#123;\n        return target.call(ctx)\n      &#125;\n\n      // Check if the toString protype of the context is the same as the global prototype,\n      // if not indicates that we are doing a check across different windows., e.g. the iframeWithdirect` test case\n      const hasSameProto = Object.getPrototypeOf(\n        Function.prototype.toString\n      ).isPrototypeOf(ctx.toString) // eslint-disable-line no-prototype-builtins\n      if (!hasSameProto) &#123;\n        // Pass the call on to the local Function.prototype.toString instead\n        return ctx.toString()\n      &#125;\n\n      return target.call(ctx)\n    &#125;\n  &#125;\n\n  const toStringProxy = new Proxy(\n    Function.prototype.toString,\n    utils.stripProxyFromErrors(handler)\n  )\n  utils.replaceProperty(Function.prototype, &#x27;toString&#x27;, &#123;\n    value: toStringProxy\n  &#125;)\n&#125;&quot;</span>,<span class="attr">replaceWithProxy</span>:<span class="string">&quot;(obj, propName, handler) =&gt; &#123;\n  const originalObj = obj[propName]\n  const proxyObj = new Proxy(obj[propName], utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, &#123; value: proxyObj &#125;)\n  utils.redirectToString(proxyObj, originalObj)\n\n  return true\n&#125;&quot;</span>,<span class="attr">replaceGetterWithProxy</span>:<span class="string">&quot;(obj, propName, handler) =&gt; &#123;\n  const fn = Object.getOwnPropertyDescriptor(obj, propName).get\n  const fnStr = fn.toString() // special getter function string\n  const proxyObj = new Proxy(fn, utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, &#123; get: proxyObj &#125;)\n  utils.patchToString(proxyObj, fnStr)\n\n  return true\n&#125;&quot;</span>,<span class="attr">replaceGetterSetter</span>:<span class="string">&quot;(obj, propName, handlerGetterSetter) =&gt; &#123;\n  const ownPropertyDescriptor = Object.getOwnPropertyDescriptor(obj, propName)\n  const handler = &#123; ...ownPropertyDescriptor &#125;\n\n  if (handlerGetterSetter.get !== undefined) &#123;\n    const nativeFn = ownPropertyDescriptor.get\n    handler.get = function() &#123;\n      return handlerGetterSetter.get.call(this, nativeFn.bind(this))\n    &#125;\n    utils.redirectToString(handler.get, nativeFn)\n  &#125;\n\n  if (handlerGetterSetter.set !== undefined) &#123;\n    const nativeFn = ownPropertyDescriptor.set\n    handler.set = function(newValue) &#123;\n      handlerGetterSetter.set.call(this, newValue, nativeFn.bind(this))\n    &#125;\n    utils.redirectToString(handler.set, nativeFn)\n  &#125;\n\n  Object.defineProperty(obj, propName, handler)\n&#125;&quot;</span>,<span class="attr">mockWithProxy</span>:<span class="string">&quot;(obj, propName, pseudoTarget, handler) =&gt; &#123;\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\n\n  utils.replaceProperty(obj, propName, &#123; value: proxyObj &#125;)\n  utils.patchToString(proxyObj)\n\n  return true\n&#125;&quot;</span>,<span class="attr">createProxy</span>:<span class="string">&quot;(pseudoTarget, handler) =&gt; &#123;\n  const proxyObj = new Proxy(pseudoTarget, utils.stripProxyFromErrors(handler))\n  utils.patchToString(proxyObj)\n\n  return proxyObj\n&#125;&quot;</span>,<span class="attr">splitObjPath</span>:<span class="string">&quot;objPath =&gt; (&#123;\n  // Remove last dot entry (property) ==&gt; `HTMLMediaElement.prototype`\n  objName: objPath.split(&#x27;.&#x27;).slice(0, -1).join(&#x27;.&#x27;),\n  // Extract last dot entry ==&gt; `canPlayType`\n  propName: objPath.split(&#x27;.&#x27;).slice(-1)[0]\n&#125;)&quot;</span>,<span class="attr">replaceObjPathWithProxy</span>:<span class="string">&quot;(objPath, handler) =&gt; &#123;\n  const &#123; objName, propName &#125; = utils.splitObjPath(objPath)\n  const obj = eval(objName) // eslint-disable-line no-eval\n  return utils.replaceWithProxy(obj, propName, handler)\n&#125;&quot;</span>,<span class="attr">execRecursively</span>:<span class="string">&quot;(obj = &#123;&#125;, typeFilter = [], fn) =&gt; &#123;\n  function recurse(obj) &#123;\n    for (const key in obj) &#123;\n      if (obj[key] === undefined) &#123;\n        continue\n      &#125;\n      if (obj[key] &amp;&amp; typeof obj[key] === &#x27;object&#x27;) &#123;\n        recurse(obj[key])\n      &#125; else &#123;\n        if (obj[key] &amp;&amp; typeFilter.includes(typeof obj[key])) &#123;\n          fn.call(this, obj[key])\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n  recurse(obj)\n  return obj\n&#125;&quot;</span>,<span class="attr">stringifyFns</span>:<span class="string">&quot;(fnObj = &#123; hello: () =&gt; &#x27;world&#x27; &#125;) =&gt; &#123;\n  // Object.fromEntries() ponyfill (in 6 lines) - supported only in Node v12+, modern browsers are fine\n  // https://github.com/feross/fromentries\n  function fromEntries(iterable) &#123;\n    return [...iterable].reduce((obj, [key, val]) =&gt; &#123;\n      obj[key] = val\n      return obj\n    &#125;, &#123;&#125;)\n  &#125;\n  return (Object.fromEntries || fromEntries)(\n    Object.entries(fnObj)\n      .filter(([key, value]) =&gt; typeof value === &#x27;function&#x27;)\n      .map(([key, value]) =&gt; [key, value.toString()]) // eslint-disable-line no-eval\n  )\n&#125;&quot;</span>,<span class="attr">materializeFns</span>:<span class="string">&quot;(fnStrObj = &#123; hello: \&quot;() =&gt; &#x27;world&#x27;\&quot; &#125;) =&gt; &#123;\n  return Object.fromEntries(\n    Object.entries(fnStrObj).map(([key, value]) =&gt; &#123;\n      if (value.startsWith(&#x27;function&#x27;)) &#123;\n        // some trickery is needed to make oldschool functions work :-)\n        return [key, eval(`() =&gt; $&#123;value&#125;`)()] // eslint-disable-line no-eval\n      &#125; else &#123;\n        // arrow functions just work\n        return [key, eval(value)] // eslint-disable-line no-eval\n      &#125;\n    &#125;)\n  )\n&#125;&quot;</span>,<span class="attr">makeHandler</span>:<span class="string">&quot;() =&gt; (&#123;\n  // Used by simple `navigator` getter evasions\n  getterValue: value =&gt; (&#123;\n    apply(target, ctx, args) &#123;\n      // Let&#x27;s fetch the value first, to trigger and escalate potential errors\n      // Illegal invocations like `navigator.__proto__.vendor` will throw here\n      utils.cache.Reflect.apply(...arguments)\n      return value\n    &#125;\n  &#125;)\n&#125;)&quot;</span>,<span class="attr">arrayEquals</span>:<span class="string">&quot;(array1, array2) =&gt; &#123;\n  if (array1.length !== array2.length) &#123;\n    return false\n  &#125;\n  for (let i = 0; i &lt; array1.length; ++i) &#123;\n    if (array1[i] !== array2[i]) &#123;\n      return false\n    &#125;\n  &#125;\n  return true\n&#125;&quot;</span>,<span class="attr">memoize</span>:<span class="string">&quot;fn =&gt; &#123;\n  const cache = []\n  return function(...args) &#123;\n    if (!cache.some(c =&gt; utils.arrayEquals(c.key, args))) &#123;\n      cache.push(&#123; key: args, value: fn.apply(this, args) &#125;)\n    &#125;\n    return cache.find(c =&gt; utils.arrayEquals(c.key, args)).value\n  &#125;\n&#125;&quot;</span>&#125;,<span class="attr">_mainFunction</span>:<span class="string">&quot;(utils, opts) =&gt; &#123;\n      try &#123;\n        // Adds a contentWindow proxy to the provided iframe element\n        const addContentWindowProxy = iframe =&gt; &#123;\n          const contentWindowProxy = &#123;\n            get(target, key) &#123;\n              // Now to the interesting part:\n              // We actually make this thing behave like a regular iframe window,\n              // by intercepting calls to e.g. `.self` and redirect it to the correct thing. :)\n              // That makes it possible for these assertions to be correct:\n              // iframe.contentWindow.self === window.top // must be false\n              if (key === &#x27;self&#x27;) &#123;\n                return this\n              &#125;\n              // iframe.contentWindow.frameElement === iframe // must be true\n              if (key === &#x27;frameElement&#x27;) &#123;\n                return iframe\n              &#125;\n              // Intercept iframe.contentWindow[0] to hide the property 0 added by the proxy.\n              if (key === &#x27;0&#x27;) &#123;\n                return undefined\n              &#125;\n              return Reflect.get(target, key)\n            &#125;\n          &#125;\n\n          if (!iframe.contentWindow) &#123;\n            const proxy = new Proxy(window, contentWindowProxy)\n            Object.defineProperty(iframe, &#x27;contentWindow&#x27;, &#123;\n              get() &#123;\n                return proxy\n              &#125;,\n              set(newValue) &#123;\n                return newValue // contentWindow is immutable\n              &#125;,\n              enumerable: true,\n              configurable: false\n            &#125;)\n          &#125;\n        &#125;\n\n        // Handles iframe element creation, augments `srcdoc` property so we can intercept further\n        const handleIframeCreation = (target, thisArg, args) =&gt; &#123;\n          const iframe = target.apply(thisArg, args)\n\n          // We need to keep the originals around\n          const _iframe = iframe\n          const _srcdoc = _iframe.srcdoc\n\n          // Add hook for the srcdoc property\n          // We need to be very surgical here to not break other iframes by accident\n          Object.defineProperty(iframe, &#x27;srcdoc&#x27;, &#123;\n            configurable: true, // Important, so we can reset this later\n            get: function() &#123;\n              return _srcdoc\n            &#125;,\n            set: function(newValue) &#123;\n              addContentWindowProxy(this)\n              // Reset property, the hook is only needed once\n              Object.defineProperty(iframe, &#x27;srcdoc&#x27;, &#123;\n                configurable: false,\n                writable: false,\n                value: _srcdoc\n              &#125;)\n              _iframe.srcdoc = newValue\n            &#125;\n          &#125;)\n          return iframe\n        &#125;\n\n        // Adds a hook to intercept iframe creation events\n        const addIframeCreationSniffer = () =&gt; &#123;\n          /* global document */\n          const createElementHandler = &#123;\n            // Make toString() native\n            get(target, key) &#123;\n              return Reflect.get(target, key)\n            &#125;,\n            apply: function(target, thisArg, args) &#123;\n              const isIframe =\n                args &amp;&amp; args.length &amp;&amp; `$&#123;args[0]&#125;`.toLowerCase() === &#x27;iframe&#x27;\n              if (!isIframe) &#123;\n                // Everything as usual\n                return target.apply(thisArg, args)\n              &#125; else &#123;\n                return handleIframeCreation(target, thisArg, args)\n              &#125;\n            &#125;\n          &#125;\n          // All this just due to iframes with srcdoc bug\n          utils.replaceWithProxy(\n            document,\n            &#x27;createElement&#x27;,\n            createElementHandler\n          )\n        &#125;\n\n        // Let&#x27;s go\n        addIframeCreationSniffer()\n      &#125; catch (err) &#123;\n        // console.warn(err)\n      &#125;\n    &#125;&quot;</span>,<span class="attr">_args</span>:[]&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="模拟bilibili登录示例"><a href="#模拟bilibili登录示例" class="headerlink" title="模拟bilibili登录示例"></a>模拟bilibili登录示例</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.select <span class="keyword">import</span> Select</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> chaojiying <span class="keyword">import</span> Chaojiying_Client</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置无头浏览器</span></span><br><span class="line">option = webdriver.ChromeOptions()</span><br><span class="line">option.add_argument(<span class="string">&#x27;--headless&#x27;</span>)</span><br><span class="line"><span class="comment"># 无头浏览器需要添加user-agent来隐藏特征</span></span><br><span class="line">option.add_argument(<span class="string">&#x27;user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36&#x27;</span>)</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(<span class="string">&#x27;https://www.bilibili.com/&#x27;</span>)</span><br><span class="line">driver.maximize_window()</span><br><span class="line">driver.implicitly_wait(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># with open(&#x27;stealth.min.js&#x27;) as f:</span></span><br><span class="line"><span class="comment">#     js = f.read()</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># driver.execute_cdp_cmd(&quot;Page.addScriptToEvaluateOnNewDocument&quot;, &#123;</span></span><br><span class="line"><span class="comment">#     &quot;source&quot;: js</span></span><br><span class="line"><span class="comment"># &#125;)</span></span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 点击登录</span></span><br><span class="line">driver.find_element(By.XPATH, <span class="string">&#x27;//*[@id=&quot;i_cecream&quot;]/div[2]/div[1]/div[1]/ul[2]/li[1]/li/div&#x27;</span>).click()</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 输入账号密码</span></span><br><span class="line"><span class="comment"># ele_user = WebDriverWait(driver,3).until(lambda d:d.find_element(By.XPATH,&#x27;/html/body/div[4]/div/div[4]/div[2]/form/div[1]/input&#x27;))</span></span><br><span class="line">ele_user = driver.find_element(By.XPATH, <span class="string">&#x27;/html/body/div[4]/div/div[4]/div[2]/form/div[1]/input&#x27;</span>)</span><br><span class="line">ele_user.send_keys(<span class="string">&quot;18775305023&quot;</span>)</span><br><span class="line">ele_pass = driver.find_element(By.XPATH, <span class="string">&#x27;/html/body/div[4]/div/div[4]/div[2]/form/div[3]/input&#x27;</span>)</span><br><span class="line">ele_pass.send_keys(<span class="string">&quot;biliuserysk7&quot;</span>)</span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录</span></span><br><span class="line">driver.find_element(By.XPATH, <span class="string">&#x27;/html/body/div[4]/div/div[4]/div[2]/div[2]/div[2]&#x27;</span>).click()</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对当前页面进行截图保存</span></span><br><span class="line">driver.save_screenshot(<span class="string">&#x27;./img/page.png&#x27;</span>)</span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 定位验证码图片的位置</span></span><br><span class="line">code_img_ele = driver.find_element(By.CLASS_NAME,<span class="string">&#x27;geetest_widget&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取验证码左上角的坐标x,y</span></span><br><span class="line">location = code_img_ele.location</span><br><span class="line"><span class="comment"># 获取验证码图片对应的长和宽</span></span><br><span class="line">size = code_img_ele.size</span><br><span class="line"></span><br><span class="line"><span class="comment"># 左上角和右下角的坐标</span></span><br><span class="line">rangle = (</span><br><span class="line">    <span class="built_in">int</span>(location[<span class="string">&#x27;x&#x27;</span>] ), <span class="built_in">int</span>(location[<span class="string">&#x27;y&#x27;</span>] ), <span class="built_in">int</span>((location[<span class="string">&#x27;x&#x27;</span>] + size[<span class="string">&#x27;width&#x27;</span>]) ),</span><br><span class="line">    <span class="built_in">int</span>((location[<span class="string">&#x27;y&#x27;</span>] + size[<span class="string">&#x27;height&#x27;</span>]))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">i = Image.<span class="built_in">open</span>(<span class="string">&#x27;./img/page.png&#x27;</span>)</span><br><span class="line">code_img_name = <span class="string">&#x27;./img/code.png&#x27;</span></span><br><span class="line"><span class="comment"># crop根据rangle元组内的坐标进行裁剪</span></span><br><span class="line">frame = i.crop(rangle)</span><br><span class="line">frame.save(code_img_name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 缩小图片</span></span><br><span class="line">code = Image.<span class="built_in">open</span>(<span class="string">&#x27;./img/code.png&#x27;</span>)</span><br><span class="line">small_img = code.resize((<span class="number">169</span>, <span class="number">216</span>))</span><br><span class="line">small_img.save(<span class="string">&#x27;./img/small_img.png&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;size&#x27;</span>,code.size, small_img.size)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 超级鹰识别验证码</span></span><br><span class="line"><span class="comment"># 将验证码提交给超级鹰进行识别</span></span><br><span class="line">chaojiying = Chaojiying_Client(<span class="string">&#x27;ye1064655698&#x27;</span>, <span class="string">&#x27;1064655698ye&#x27;</span>, <span class="string">&#x27;956846&#x27;</span>)  <span class="comment"># 用户中心&gt;&gt;软件ID 生成一个替换 96001</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;chaojiying&#x27;</span>,chaojiying)</span><br><span class="line">im = <span class="built_in">open</span>(<span class="string">&#x27;./img/small_img.png&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>).read()  <span class="comment"># 本地图片文件路径 来替换 a.jpg 有时WIN系统须要//</span></span><br><span class="line"><span class="comment"># 9004是验证码类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;chaojiying.PostPic&#x27;</span>,chaojiying.PostPic(im, <span class="number">9004</span>)[<span class="string">&#x27;pic_str&#x27;</span>])</span><br><span class="line">result = chaojiying.PostPic(im, <span class="number">9004</span>)[<span class="string">&#x27;pic_str&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;result：&quot;</span>,result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">all_list = []  <span class="comment"># 要存储即将被点击的点的坐标  [[x1,y1],[x2,y2]]</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;|&#x27;</span> <span class="keyword">in</span> result:</span><br><span class="line">    list_1 = result.split(<span class="string">&#x27;|&#x27;</span>)</span><br><span class="line">    count_1 = <span class="built_in">len</span>(list_1)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(count_1):</span><br><span class="line">        xy_list = []</span><br><span class="line">        x = <span class="built_in">int</span>(list_1[i].split(<span class="string">&#x27;,&#x27;</span>)[<span class="number">0</span>])</span><br><span class="line">        y = <span class="built_in">int</span>(list_1[i].split(<span class="string">&#x27;,&#x27;</span>)[<span class="number">1</span>])</span><br><span class="line">        xy_list.append(x)</span><br><span class="line">        xy_list.append(y)</span><br><span class="line">        all_list.append(xy_list)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    x = <span class="built_in">int</span>(result.split(<span class="string">&#x27;,&#x27;</span>)[<span class="number">0</span>])</span><br><span class="line">    y = <span class="built_in">int</span>(result.split(<span class="string">&#x27;,&#x27;</span>)[<span class="number">1</span>])</span><br><span class="line">    xy_list = []</span><br><span class="line">    xy_list.append(x)</span><br><span class="line">    xy_list.append(y)</span><br><span class="line">    all_list.append(xy_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历列表，使用动作链对每一个列表元素对应的x,y指定的位置进行点击操作</span></span><br><span class="line"><span class="comment"># x,y坐标乘2和0.8，是由于之前图片缩放过，所以*2，0.8是因为本人电脑桌面缩放比例为125%，需要还原成1</span></span><br><span class="line"><span class="keyword">for</span> l <span class="keyword">in</span> all_list:</span><br><span class="line">    x = l[<span class="number">0</span>] * <span class="number">2</span> * <span class="number">0.8</span></span><br><span class="line">    y = l[<span class="number">1</span>] * <span class="number">2</span> * <span class="number">0.8</span></span><br><span class="line">    <span class="comment"># 将点击操作的参照物移动到指定的模块，</span></span><br><span class="line">    <span class="comment"># 若用方法二获取的验证码图片，要添加下面代码对code_img_ele赋值</span></span><br><span class="line">    <span class="comment"># code_img_ele = bro.find_element_by_xpath(&#x27;/html/body/div[2]/div[2]/div[6]/div/div/div[2]/div[1]/div/div[2]/img&#x27;)</span></span><br><span class="line">    ActionChains(driver).move_to_element_with_offset(code_img_ele, x, y).click().perform()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;点击已完成&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 完成动作链点击操作后，定位确认按钮并点击</span></span><br><span class="line">driver.find_element(By.CLASS_NAME,<span class="string">&#x27;geetest_commit&#x27;</span>).click()</span><br></pre></td></tr></table></figure>





<h2 id="移动测试"><a href="#移动测试" class="headerlink" title="移动测试"></a>移动测试</h2><h3 id="Appium"><a href="#Appium" class="headerlink" title="Appium"></a>Appium</h3><p>优势</p>
<ul>
<li>支持的语言多</li>
<li>支持的平台多</li>
</ul>
<p>环境搭建</p>
<ul>
<li>安装appium的程序</li>
</ul>
<p>下载appium桌面程序，地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/appium/appium-desktop/releases?page=3</span><br></pre></td></tr></table></figure>



<ul>
<li>在python中安装 Appium-Python-Client</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install -i https://mirrors.aliyun.com/pypi/simple/ Appium-Python-Client</span><br></pre></td></tr></table></figure>



<h4 id="移动测试介绍"><a href="#移动测试介绍" class="headerlink" title="移动测试介绍"></a>移动测试介绍</h4><h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><p>1、java sdk</p>
<p>2、Android sdk</p>
<p>3、虚拟机安装</p>
<h4 id="adb的使用"><a href="#adb的使用" class="headerlink" title="adb的使用"></a>adb的使用</h4><p>1、关系</p>
<p>会在电脑上创建出来一个服务(ADB服务)手机连上电脑后，都会与服务建立连接。要想发送指令给手机，需要把指令发送到服务中。</p>
<p>2、定义</p>
<p>就是一个Android Debug Bridge 安卓调试桥即包含ADB服务，也包含了与服务对应的Client。</p>
<p>3、作用</p>
<p>通过命令行去操作手机</p>
<p>4、命令</p>
<p><strong>重要</strong></p>
<p>服务（如果发现代码连不上手机了）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb kill-server</span><br><span class="line">adb start-server	</span><br></pre></td></tr></table></figure>

<ul>
<li>查看设备</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb devices</span><br></pre></td></tr></table></figure>

<ul>
<li>进入手机终端</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br></pre></td></tr></table></figure>



<ul>
<li>获取信息</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 获取数据android版本</span><br><span class="line">adb shell getprop ro.build.version.release</span><br><span class="line"></span><br><span class="line"># 获取手机当前运行的程序和界面的名称</span><br><span class="line">adb shell dumpsys window | findstr mFocusedApp</span><br></pre></td></tr></table></figure>



<p><strong>其他</strong></p>
<ul>
<li>文件传输</li>
</ul>
<p>传输到手机</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb push 电脑上的文件 手机上的位置</span><br></pre></td></tr></table></figure>

<p>传输到电脑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb pull 手机上的文件 电脑上的位置</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可直接拖曳传输，使用命令麻烦</p>
</blockquote>
<ul>
<li>软件安装卸载</li>
</ul>
<p>安装应用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb install 电脑上的apk文件路径</span><br></pre></td></tr></table></figure>

<p>卸载</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb uninstall 应用的包名</span><br></pre></td></tr></table></figure>



<ul>
<li>获取其他信息</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start -W 包名/.启动名</span><br></pre></td></tr></table></figure>



<h4 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h4><p>基础API</p>
<p>driver</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">driver.close_app() 关闭打开的应用</span><br><span class="line">driver.quit() 断开连接</span><br><span class="line">driver.install_app() 安装应用（apk在电脑的绝对路径）</span><br><span class="line">driver.remove_app() 卸载应用</span><br><span class="line">driver.is_app_installed(&quot;应用的包名&quot;) 判断应用是否安装</span><br><span class="line">driver.push_file(&quot;目标位置&quot;,&quot;base64编码的内容&quot;)</span><br><span class="line">driver.pull_file(&quot;来源位置&quot;) 返回base64编码的内容</span><br><span class="line">driver.page_source() 获取界面xml源码</span><br><span class="line">driver.current_package() 获取当前操作应用的包名</span><br><span class="line">driver.current_activity() 获取当前操作的页面的名称</span><br></pre></td></tr></table></figure>



<p>element</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">text 获取元素文本内容</span><br><span class="line">click() 点击元素对应位置</span><br><span class="line">get_attribute(&quot;属性名称&quot;) 获取属性值</span><br><span class="line">location 获取元素左上角的坐标（相对屏幕的左上角）</span><br><span class="line">size 获取元素的宽高（字典）</span><br></pre></td></tr></table></figure>





<h4 id="模拟手势"><a href="#模拟手势" class="headerlink" title="模拟手势"></a>模拟手势</h4><p>拖曳操作</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.drag_and_drop(ele1,ele2)</span><br></pre></td></tr></table></figure>



<p>高级模拟手势</p>
<p>TouchAction</p>
<ul>
<li><p>tap：轻敲</p>
</li>
<li><p>press：按压</p>
</li>
<li><p>long_press：长按</p>
</li>
<li><p>wait(毫秒数)：等待</p>
</li>
<li><p>move_to：移动到</p>
</li>
<li><p>release：释放（松手）</p>
</li>
<li><p>perform：执行（最后要）</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> appium.webdriver.common.touch_action <span class="keyword">import</span> TouchAction</span><br><span class="line"></span><br><span class="line">TouchAction(driver).press(ele1).move_to(ele2).wait(<span class="number">2000</span>).release().perform()</span><br></pre></td></tr></table></figure>



<h4 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h4><p>进入进行图形手势验证</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> appium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> appium.webdriver.common.appiumby <span class="keyword">import</span> AppiumBy</span><br><span class="line"><span class="keyword">from</span> appium.webdriver.common.touch_action <span class="keyword">import</span> TouchAction</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接移动设备所必须的参数</span></span><br><span class="line">desired_caps=&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前要测试的设备的名称</span></span><br><span class="line">desired_caps[<span class="string">&#x27;deviceName&#x27;</span>] = <span class="string">&#x27;127.0.0.1:62001&#x27;</span></span><br><span class="line"><span class="comment"># 系统</span></span><br><span class="line">desired_caps[<span class="string">&#x27;platformName&#x27;</span>] = <span class="string">&#x27;Android&#x27;</span></span><br><span class="line"><span class="comment"># 系统的版本</span></span><br><span class="line">desired_caps[<span class="string">&#x27;platformVersion&#x27;</span>] = <span class="string">&#x27;7.1&#x27;</span></span><br><span class="line"><span class="comment"># 要启动app的名称（包名）</span></span><br><span class="line">desired_caps[<span class="string">&#x27;appPackage&#x27;</span>] = <span class="string">&#x27;com.android.settings&#x27;</span></span><br><span class="line"><span class="comment"># 要启动的app的哪个界面</span></span><br><span class="line">desired_caps[<span class="string">&#x27;appActivity&#x27;</span>] = <span class="string">&#x27;.Settings&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(desired_caps)</span><br><span class="line"></span><br><span class="line">driver = webdriver.Remote(<span class="string">&quot;http://127.0.0.1:4723/wd/hub&quot;</span>,</span><br><span class="line">                 desired_capabilities=desired_caps)</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># driver.find_element(AppiumBy.XPATH,&#x27;//*[@text=&quot;设置&quot;]&#x27;).click()</span></span><br><span class="line"><span class="comment"># time.sleep(1)</span></span><br><span class="line"></span><br><span class="line">ele1 = driver.find_element(AppiumBy.XPATH,<span class="string">&#x27;//*[@text=&quot;声音&quot;]&#x27;</span>)</span><br><span class="line">ele2 = driver.find_element(AppiumBy.XPATH,<span class="string">&#x27;//*[@text=&quot;更换壁纸&quot;]&#x27;</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">TouchAction(driver).press(ele1).wait(<span class="number">500</span>).move_to(ele2).release().perform()</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">driver.find_element(AppiumBy.XPATH,<span class="string">&#x27;//*[@text=&quot;安全&quot;]&#x27;</span>).click()</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">driver.find_element(AppiumBy.XPATH,<span class="string">&#x27;//*[@text=&quot;屏幕锁定&quot;]&#x27;</span>).click()</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">driver.find_element(AppiumBy.XPATH,<span class="string">&#x27;//*[@text=&quot;图案&quot;]&#x27;</span>).click()</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">TouchAction(driver)\</span><br><span class="line">    .press(x=<span class="number">143</span>,y=<span class="number">615</span>)\</span><br><span class="line">    .wait(<span class="number">200</span>)\</span><br><span class="line">    .move_to(x=<span class="number">358</span>,y=<span class="number">615</span>)\</span><br><span class="line">    .wait(<span class="number">200</span>)\</span><br><span class="line">    .move_to(x=<span class="number">574</span>,y=<span class="number">615</span>)\</span><br><span class="line">    .wait(<span class="number">200</span>)\</span><br><span class="line">    .move_to(x=<span class="number">358</span>,y=<span class="number">829</span>)\</span><br><span class="line">    .wait(<span class="number">200</span>)\</span><br><span class="line">    .move_to(x=<span class="number">143</span>,y=<span class="number">1045</span>)\</span><br><span class="line">    .wait(<span class="number">200</span>)\</span><br><span class="line">    .move_to(x=<span class="number">358</span>,y=<span class="number">1045</span>)\</span><br><span class="line">    .wait(<span class="number">200</span>)\</span><br><span class="line">    .move_to(x=<span class="number">574</span>,y=<span class="number">1045</span>)\</span><br><span class="line">    .release()\</span><br><span class="line">    .perform()</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">driver.close_app()</span><br><span class="line">driver.quit()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">driver.device_time 获取手机时间</span><br><span class="line">driver.get_window_size() 获取屏幕大小</span><br><span class="line">driver.network_connection <span class="comment"># 获取手机网络信息 1 飞行模式；2 wifi 4 移动数据 6=2+4</span></span><br><span class="line">driver.set_network_connection(网络模式数字) <span class="comment"># 设置手机网络信息</span></span><br><span class="line">driver.keyevent(<span class="string">&quot;按键数字&quot;</span>) <span class="comment"># 点击按键</span></span><br><span class="line">driver.get_screenshot_as_file(<span class="string">&quot;图片路径&quot;</span>) <span class="comment"># 截屏</span></span><br><span class="line">driver.open_notifications() <span class="comment"># 打开通知栏</span></span><br></pre></td></tr></table></figure>





<h2 id="pytest"><a href="#pytest" class="headerlink" title="pytest"></a>pytest</h2><h3 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h3><p>pytest是python的一种单元测试框架，同自带的unittest测试框架类似，相比于unittest框架使用起来更简洁,效率更高.</p>
<h3 id="2、特点"><a href="#2、特点" class="headerlink" title="2、特点"></a>2、特点</h3><p>1.非常容易上手,入门简单.文档丰富，文档中有很多实例可以参考</p>
<p>2.支持简单的单元测试和复杂的功能测试.<br>3.支持参数化.<br>4.执行测试过程中可以将某些测试跳过，或者对某些预期失败的Case标记成失败</p>
<p>5.支持重复执行失败的Case.<br>6.支持运行由Nose,Unittest编写的测试Case7.具有很多第三方插件.并且可以自定义扩展8.方便的和持续集成工具集成.</p>
<h3 id="3、安装"><a href="#3、安装" class="headerlink" title="3、安装"></a>3、安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U pytest</span><br></pre></td></tr></table></figure>



<h3 id="4、基本使用"><a href="#4、基本使用" class="headerlink" title="4、基本使用"></a>4、基本使用</h3><h4 id="运行方式"><a href="#运行方式" class="headerlink" title="运行方式"></a>运行方式</h4><p>运行方式一</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test_01</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_a</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;test_a执行了&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_b</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;test_b执行了&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pytest.main([<span class="string">&quot;-s&quot;</span>,<span class="string">&quot;要运行的文件名&quot;</span>])</span><br></pre></td></tr></table></figure>



<p>运行方式二</p>
<p>终端运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest</span><br></pre></td></tr></table></figure>



<h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[pytest]</span></span><br><span class="line"></span><br><span class="line"><span class="attr">addopts</span> = -s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 路径</span></span><br><span class="line"><span class="attr">testpath</span> = ./</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件名（要运行的）</span></span><br><span class="line"><span class="attr">python_files</span> = test_*.py *test.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类名（要运行的）</span></span><br><span class="line"><span class="attr">python_classes</span> = Test_*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数名（要运行的）</span></span><br><span class="line"><span class="attr">python_functions</span> = test_*</span><br></pre></td></tr></table></figure>



<h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><p>assert 表达式</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test_01</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_a</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;test_a执行了&#x27;</span>)</span><br><span class="line">        <span class="keyword">assert</span> <span class="number">1</span>==<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_b</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;test_b执行了&#x27;</span>)</span><br><span class="line">        <span class="keyword">assert</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pytest.main([<span class="string">&#x27;-s&#x27;</span>,<span class="string">&#x27;test_01.py&#x27;</span>])</span><br></pre></td></tr></table></figure>



<h4 id="标记跳过"><a href="#标记跳过" class="headerlink" title="标记跳过"></a>标记跳过</h4><p>@pytest.mark.xfail(raises&#x3D;)：标记错误（如果有错误，提示）</p>
<p>@pytest.mark.skip(reason&#x3D;)：标记跳过（跳过不执行）</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.xfail(<span class="params">raises=ZeroDivisionError</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_a</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;test_a执行了&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.skip(<span class="params">reason=<span class="string">&#x27;我想跳过&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_b</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;test_b执行了&#x27;</span>)</span><br><span class="line">    <span class="keyword">assert</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pytest.main([<span class="string">&#x27;-s&#x27;</span>,<span class="string">&#x27;test_02.py&#x27;</span>])</span><br></pre></td></tr></table></figure>



<h4 id="参数化"><a href="#参数化" class="headerlink" title="参数化"></a>参数化</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.parametrize(<span class="params">[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>],[(<span class="params"><span class="number">1</span>,<span class="number">2</span></span>),(<span class="params"><span class="number">50</span>,<span class="number">60</span></span>)]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_a</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;test_a执行了&#x27;</span>)</span><br><span class="line">    <span class="keyword">assert</span> a+b &gt; <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pytest.main([<span class="string">&#x27;-s&#x27;</span>,<span class="string">&#x27;test_03.py&#x27;</span>])</span><br></pre></td></tr></table></figure>



<h4 id="夹具"><a href="#夹具" class="headerlink" title="夹具"></a>夹具</h4><p><a target="_blank" rel="noopener" href="https://docs.pytest.org/en/latest/how-to/xunit_setup.html#xunitsetup">https://docs.pytest.org/en/latest/how-to/xunit_setup.html#xunitsetup</a></p>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>在测试之前和之后执行，用于固定测试环境，及清理回收测试资源</p>
<h5 id="级别"><a href="#级别" class="headerlink" title="级别"></a>级别</h5><ul>
<li>模块级（参数可选）</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 模块级别</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setup_module</span>(<span class="params">module</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;setup_module&#x27;</span>,module)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">teardown_module</span>(<span class="params">module</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;teardown_module&#x27;</span>,module)</span><br></pre></td></tr></table></figure>



<ul>
<li>类级（@classmethod 可不加）</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestOne</span>():</span><br><span class="line">    <span class="comment"># 类级别</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setup_class</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;setup_class...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">teardown_class</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;teardown_class...&#x27;</span>)</span><br></pre></td></tr></table></figure>



<ul>
<li>函数级</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 函数级别</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setup_function</span>(<span class="params">args</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;setup_function&#x27;</span>,args)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">teardown_function</span>(<span class="params">args</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;teardown_function&#x27;</span>,args)</span><br></pre></td></tr></table></figure>



<ul>
<li>方法级</li>
</ul>
<p>包含类中的每个方法</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestOne</span>():</span><br><span class="line">    <span class="comment"># 方法级别</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setup_method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;setup_method...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">teardown_method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;teardown_method...&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h5 id="fixture装饰器"><a href="#fixture装饰器" class="headerlink" title="fixture装饰器"></a>fixture装饰器</h5><p><strong>介绍</strong></p>
<ul>
<li><p>除了setup和teardown，pytest提供fixture进行更为强大的夹具使用。</p>
</li>
<li><p>我们可以把夹具看为一个过程，</p>
</li>
<li><p>它也可以是具备返回值的，(该过程创建了某种资源)，正是我们测试中所需要</p>
</li>
</ul>
<p>示例</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义夹具</span></span><br><span class="line"><span class="meta">@pytest.fixture()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">before</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;before...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义有返回值的夹具</span></span><br><span class="line"><span class="meta">@pytest.fixture()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;login...&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;user&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义有参数的夹具</span></span><br><span class="line"><span class="meta">@pytest.fixture()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_data</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;get_data...&#x27;</span>,request)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用夹具（before</span></span><br><span class="line"><span class="meta">@pytest.mark.usefixtures(<span class="params"><span class="string">&#x27;before&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_01</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;test_01...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用带参数加的夹具（login</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_02</span>(<span class="params">login</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;test_02...&#x27;</span>,login)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义初始化参数的夹具</span></span><br><span class="line"><span class="meta">@pytest.fixture(<span class="params">params=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_data</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;初始化的参数是：&#x27;</span>,request.param)</span><br><span class="line">    <span class="keyword">return</span> request.param</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用夹具（init_data，参数长度=执行次数，</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_03</span>(<span class="params">init_data</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;test_03...&#x27;</span>,init_data)</span><br><span class="line">    <span class="keyword">assert</span> init_data&gt;<span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pytest.main([<span class="string">&#x27;-s&#x27;</span>,<span class="string">&#x27;test_05.py&#x27;</span>])</span><br></pre></td></tr></table></figure>



<h5 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h5><p>pytest-html</p>
<p>安装</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install pytest-html</span><br><span class="line"><span class="comment"># pytest-html 依赖 py</span></span><br><span class="line">pip install -U py</span><br></pre></td></tr></table></figure>





<p>pytest-ordering</p>
<p>按顺序执行测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pytest-ordering</span><br></pre></td></tr></table></figure>



<p>应用</p>
<p>数字越小越先执行（&gt;&#x3D;0）</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.run(<span class="params">order=<span class="number">1</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_01</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.run(<span class="params">order=<span class="number">3</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_02</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.run(<span class="params">order=<span class="number">2</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_03</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pytest.main([<span class="string">&#x27;-s&#x27;</span>,<span class="string">&#x27;test_06.py&#x27;</span>])</span><br></pre></td></tr></table></figure>



<p>pytest-returnfailures</p>
<p>作用：失败后多次执行</p>
<p>安装</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pytest-returnfailures</span><br></pre></td></tr></table></figure>



<p>使用</p>
<ul>
<li>命令行方式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest --returns</span><br></pre></td></tr></table></figure>



<ul>
<li>配置文件方式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[pytest]</span><br><span class="line"></span><br><span class="line">addopts = -s --returns 5 --html=./report.html </span><br></pre></td></tr></table></figure>





<h2 id="unittest"><a href="#unittest" class="headerlink" title="unittest"></a>unittest</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>unittest是python自带的一个模块，可以用它进行单元测试</p>
<h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>以上所需selenium操作，仅仅是完成了自动化测试的操作部分。</p>
<p>关于是否和预期一致的对比，可以借助unittest来完成</p>
<h3 id="为什么使用unittest？"><a href="#为什么使用unittest？" class="headerlink" title="为什么使用unittest？"></a>为什么使用unittest？</h3><p>1.能够组织多个用例去执行</p>
<p>2.提供丰富的断言方法<br>3.提供丰富的日志与测试结果</p>
<h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><ul>
<li>TestCase</li>
</ul>
<p>测试用例：用类的方式组织对一个功能的多项测试</p>
<ul>
<li>Fixture</li>
</ul>
<p>夹具，用来固定测试环境。</p>
<ul>
<li>TestSuite</li>
</ul>
<p>测试套件：组织多个TestCase</p>
<ul>
<li>TestRunner</li>
</ul>
<p>测试执行：来执行TestSuit，并可以导出测试结果</p>
<ul>
<li><p>其他</p>
</li>
<li><p>TestResult 测试报告（某种格式的测试结果）</p>
</li>
<li><p>TestLoader 根据某一规则找到TestSuite</p>
</li>
</ul>
<h3 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h3><p>三个步骤</p>
<p>1.创建测试类</p>
<p>需要继承于unittest.TestCase</p>
<p>2.书写测试方法</p>
<p>需要以test开头的示例方法，且不能有参数</p>
<p>3.执行测试（在pycharm中可以省略）</p>
<p>例</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestOne</span>(unittest.TestCase):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_01</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;这是test_01&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_02</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;这是test_02&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure>





<h3 id="断言-1"><a href="#断言-1" class="headerlink" title="断言"></a>断言</h3></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://space7z.github.io">ysk</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://space7z.github.io/2024/01/08/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">https://space7z.github.io/2024/01/08/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://space7z.github.io" target="_blank">ysk-blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/tx.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/10/20/c/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="c语言学习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">c语言学习笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/tx.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ysk</div><div class="author-info__description">ysk的个人博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/space7z"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/space7z" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:702010343@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.</span> <span class="toc-text">软件测试的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB"><span class="toc-number">1.2.</span> <span class="toc-text">常见的测试分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%8C%89%E9%98%B6%E6%AE%B5%E5%88%92%E5%88%86"><span class="toc-number">1.2.1.</span> <span class="toc-text">1、按阶段划分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%8C%89%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%A7%81%E5%BA%A6%E5%88%92%E5%88%86"><span class="toc-number">1.2.2.</span> <span class="toc-text">2、按代码可见度划分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%B8%93%E9%A1%B9"><span class="toc-number">1.2.3.</span> <span class="toc-text">3、专项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%A8%E9%87%8F%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%87%8D%E7%82%B95%E9%A1%B9"><span class="toc-number">1.3.</span> <span class="toc-text">质量模型的重点5项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B%E7%9A%846%E5%90%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.4.</span> <span class="toc-text">测试流程的6各步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B"><span class="toc-number">1.5.</span> <span class="toc-text">测试用例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%94%A8%E4%BE%8B%EF%BC%9F"><span class="toc-number">1.5.1.</span> <span class="toc-text">1、什么是用例？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1%E7%BC%96%E5%86%99%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.5.2.</span> <span class="toc-text">2、用例设计编写格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.3.</span> <span class="toc-text">测试用例的设计方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E4%BB%B7%E7%B1%BB%E5%88%92%E5%88%86%E6%B3%95"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">等价类划分法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E"><span class="toc-number">1.5.3.1.1.</span> <span class="toc-text">说明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">1.5.3.1.2.</span> <span class="toc-text">分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.5.3.1.3.</span> <span class="toc-text">步骤</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">1.5.3.1.4.</span> <span class="toc-text">例子</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.5.3.1.5.</span> <span class="toc-text">适用场景</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%B9%E7%95%8C%E5%80%BC%E6%B3%95"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">边界值法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.6.</span> <span class="toc-text">测试模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#V%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.6.1.</span> <span class="toc-text">V模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#W%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.6.2.</span> <span class="toc-text">W模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%BC%BA%E9%99%B7"><span class="toc-number">1.7.</span> <span class="toc-text">软件缺陷</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95"><span class="toc-number">2.</span> <span class="toc-text">自动化测试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">什么是自动化测试？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-number">2.2.</span> <span class="toc-text">自动化测试常用工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3-UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6"><span class="toc-number">2.2.1.</span> <span class="toc-text">接口&#x2F;UI自动化测试框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6"><span class="toc-number">2.2.2.</span> <span class="toc-text">移动自动化测试框架</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#selenium"><span class="toc-number">2.3.</span> <span class="toc-text">selenium</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">2.3.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">2.3.2.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">2.3.3.</span> <span class="toc-text">基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">1、元素操作方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0"><span class="toc-number">2.3.3.1.1.</span> <span class="toc-text">查找元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E5%85%83%E7%B4%A0"><span class="toc-number">2.3.3.1.2.</span> <span class="toc-text">操作元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E5%85%83%E7%B4%A0%E5%87%BA%E7%8E%B0"><span class="toc-number">2.3.3.1.3.</span> <span class="toc-text">等待元素出现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.3.2.</span> <span class="toc-text">2、浏览器操作方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E9%BC%A0%E6%A0%87%E6%8E%A7%E5%88%B6"><span class="toc-number">2.3.3.3.</span> <span class="toc-text">3、鼠标控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E9%94%AE%E7%9B%98%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.3.4.</span> <span class="toc-text">4、键盘操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E4%B8%8B%E6%8B%89%E6%A1%86"><span class="toc-number">2.3.3.5.</span> <span class="toc-text">5、下拉框</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E5%BC%B9%E5%87%BA%E6%A1%86"><span class="toc-number">2.3.3.6.</span> <span class="toc-text">6、弹出框</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81%E6%BB%9A%E5%8A%A8%E8%BD%AE"><span class="toc-number">2.3.3.7.</span> <span class="toc-text">7、滚动轮</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81%E5%88%87%E6%8D%A2frame%E8%A1%A8%E5%8D%95"><span class="toc-number">2.3.3.8.</span> <span class="toc-text">8、切换frame表单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E3%80%81%E5%A4%9A%E7%AA%97%E5%8F%A3%E7%9A%84%E5%88%87%E6%8D%A2"><span class="toc-number">2.3.3.9.</span> <span class="toc-text">9、多窗口的切换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10%E3%80%81%E6%88%AA%E5%9B%BE%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.3.10.</span> <span class="toc-text">10、截图操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11%E3%80%81%E9%AA%8C%E8%AF%81%E7%A0%81"><span class="toc-number">2.3.3.11.</span> <span class="toc-text">11、验证码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E4%BD%9CAPI%EF%BC%88selenium4%E6%96%B0%E5%A2%9E%EF%BC%89"><span class="toc-number">2.3.3.12.</span> <span class="toc-text">动作API（selenium4新增）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9A%82%E5%81%9C%EF%BC%88pause%EF%BC%89"><span class="toc-number">2.3.3.12.1.</span> <span class="toc-text">暂停（pause）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%E6%89%80%E6%9C%89%E5%8A%A8%E4%BD%9C"><span class="toc-number">2.3.3.12.2.</span> <span class="toc-text">释放所有动作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%94%AE%E7%9B%98"><span class="toc-number">2.3.3.12.3.</span> <span class="toc-text">键盘</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6"><span class="toc-number">2.3.4.</span> <span class="toc-text">进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#selenium%E9%9A%90%E8%97%8F%E6%8C%87%E7%BA%B9%E7%89%B9%E5%BE%81"><span class="toc-number">2.3.4.1.</span> <span class="toc-text">selenium隐藏指纹特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9Fbilibili%E7%99%BB%E5%BD%95%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.3.4.2.</span> <span class="toc-text">模拟bilibili登录示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E6%B5%8B%E8%AF%95"><span class="toc-number">2.4.</span> <span class="toc-text">移动测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Appium"><span class="toc-number">2.4.1.</span> <span class="toc-text">Appium</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E6%B5%8B%E8%AF%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.4.1.1.</span> <span class="toc-text">移动测试介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-number">2.4.1.2.</span> <span class="toc-text">环境搭建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#adb%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.4.1.3.</span> <span class="toc-text">adb的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C"><span class="toc-number">2.4.1.4.</span> <span class="toc-text">基础操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E6%89%8B%E5%8A%BF"><span class="toc-number">2.4.1.5.</span> <span class="toc-text">模拟手势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B"><span class="toc-number">2.4.1.6.</span> <span class="toc-text">综合案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C"><span class="toc-number">2.4.1.7.</span> <span class="toc-text">其他操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pytest"><span class="toc-number">2.5.</span> <span class="toc-text">pytest</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.5.1.</span> <span class="toc-text">1、介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%89%B9%E7%82%B9"><span class="toc-number">2.5.2.</span> <span class="toc-text">2、特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%AE%89%E8%A3%85"><span class="toc-number">2.5.3.</span> <span class="toc-text">3、安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">2.5.4.</span> <span class="toc-text">4、基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F"><span class="toc-number">2.5.4.1.</span> <span class="toc-text">运行方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">2.5.4.2.</span> <span class="toc-text">配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%AD%E8%A8%80"><span class="toc-number">2.5.4.3.</span> <span class="toc-text">断言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E8%B7%B3%E8%BF%87"><span class="toc-number">2.5.4.4.</span> <span class="toc-text">标记跳过</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E5%8C%96"><span class="toc-number">2.5.4.5.</span> <span class="toc-text">参数化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%B9%E5%85%B7"><span class="toc-number">2.5.4.6.</span> <span class="toc-text">夹具</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">2.5.4.6.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%A7%E5%88%AB"><span class="toc-number">2.5.4.6.2.</span> <span class="toc-text">级别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#fixture%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-number">2.5.4.6.3.</span> <span class="toc-text">fixture装饰器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6"><span class="toc-number">2.5.4.6.4.</span> <span class="toc-text">插件</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unittest"><span class="toc-number">2.6.</span> <span class="toc-text">unittest</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.6.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8-1"><span class="toc-number">2.6.2.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8unittest%EF%BC%9F"><span class="toc-number">2.6.3.</span> <span class="toc-text">为什么使用unittest？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">2.6.4.</span> <span class="toc-text">核心概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">2.6.5.</span> <span class="toc-text">入门案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%AD%E8%A8%80-1"><span class="toc-number">2.6.6.</span> <span class="toc-text">断言</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/08/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="无题">无题</a><time datetime="2024-01-08T09:05:41.338Z" title="发表于 2024-01-08 17:05:41">2024-01-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/20/c/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="c语言学习笔记">c语言学习笔记</a><time datetime="2023-10-20T11:07:14.000Z" title="发表于 2023-10-20 19:07:14">2023-10-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/17/Nodejs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Nodejs学习笔记">Nodejs学习笔记</a><time datetime="2023-10-17T05:14:48.000Z" title="发表于 2023-10-17 13:14:48">2023-10-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/24/nginx%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/" title="nginx使用笔记">nginx使用笔记</a><time datetime="2023-09-24T14:08:38.000Z" title="发表于 2023-09-24 22:08:38">2023-09-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/09/09/java/java%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/" title="java微服务项目搭建笔记">java微服务项目搭建笔记</a><time datetime="2023-09-09T14:42:12.000Z" title="发表于 2023-09-09 22:42:12">2023-09-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By ysk</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="2062886130" data-server="netease" data-type="song" data-fixed="true" data-autoplay="true"> </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div></body></html>